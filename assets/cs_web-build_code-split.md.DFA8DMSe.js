import{_ as i,c as a,o as n,a4 as l}from"./chunks/framework.DQcV7ckZ.js";const o=JSON.parse('{"title":"代码分割","description":"","frontmatter":{"title":"代码分割"},"headers":[],"relativePath":"cs/web-build/code-split.md","filePath":"cs/web-build/code-split.md"}'),h={name:"cs/web-build/code-split.md"};function p(t,s,e,k,d,r){return n(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="代码分割-code-splitting" tabindex="-1">代码分割 (Code Splitting) <a class="header-anchor" href="#代码分割-code-splitting" aria-label="Permalink to &quot;代码分割 (Code Splitting)&quot;">​</a></h1><p><strong>名词解释</strong>：</p><ul><li><code>bundle</code>: 整体的打包产物，包含 JS 和各种静态资源。</li><li><code>chunk</code>: 打包后的 JS 文件，是 bundle 的子集。</li><li><code>vendor</code>: 第三方包的打包产物，是一种特殊的 chunk。</li></ul><h2 id="为什么需要代码分割" tabindex="-1">为什么需要代码分割？ <a class="header-anchor" href="#为什么需要代码分割" aria-label="Permalink to &quot;为什么需要代码分割？&quot;">​</a></h2><p>如果不进行代码分割，所有代码（业务逻辑 + 第三方库）都会被打包进一个巨大的 <code>index.js</code> 文件中。这会导致：</p><ol><li><strong>首屏加载慢</strong>：用户需要下载完整个 <code>js</code> 文件才能看到页面。</li><li><strong>缓存利用率低</strong>：修改任意一行业务代码，整个大文件都需要重新下载。</li></ol><blockquote><p>一般而言，对于线上站点，服务端在响应资源时，会加上 <code>cache-control</code> 响应头，以指定浏览器的<strong>强缓存</strong>。比如 <code>cache-control: max-age=31536000</code>，表示资源过期时间为一年。在过期之前，访问相同的资源 URL，浏览器直接利用本地的缓存，并不用给服务端发请求。</p></blockquote><h2 id="webpack-代码分割" tabindex="-1">Webpack 代码分割 <a class="header-anchor" href="#webpack-代码分割" aria-label="Permalink to &quot;Webpack 代码分割&quot;">​</a></h2><p>Webpack 4+ 内置了 <code>SplitChunksPlugin</code> 插件，用于实现代码分割。通过 <code>optimization.splitChunks</code> 配置项，可以灵活地控制分包策略。</p><h3 id="核心概念-chunk" tabindex="-1">核心概念：Chunk <a class="header-anchor" href="#核心概念-chunk" aria-label="Permalink to &quot;核心概念：Chunk&quot;">​</a></h3><p>Webpack 在构建流程中会生成三种类型的 Chunk：</p><ol><li><strong>Initial Chunk</strong>：入口模块（entry）及其同步依赖打包成的 Chunk。</li><li><strong>Async Chunk</strong>：通过 <code>import(&#39;./xx&#39;)</code> 动态导入的模块打包成的 Chunk。</li><li><strong>Runtime Chunk</strong>：Webpack 的运行时代码（包含模块映射关系等）。</li></ol><p><strong>构建 <code>chunk</code> 流程</strong>：</p><ol><li><p>首先根据 <code>entry</code> 配置创建若干 <code>Chunk</code> 对象；</p></li><li><p>遍历构建(Make)阶段找到的所有 Module 对象，同一 <code>entry</code> 下的模块分配到对应的 <code>Chunk</code> 中；</p></li><li><p>遇到异步模块则创建新的 <code>Chunk</code> 对象，并将异步模块放入该 <code>Chunk</code>；</p></li><li><p>分配完毕后，根据 <code>SplitChunksPlugin</code> 的启发式算法进一步对这些 <code>Chunk</code> 执行裁剪、拆分、合并、代码调优，最终调整成运行性能更优的形态；</p></li><li><p>最后，将这些 <code>Chunk</code> 一个个输出成最终的产物 <code>Asset</code> 文件，编译工作到此结束。</p></li></ol><p>一般的，Webpack 默认分包策略可能会遇到<strong>模块重复打包</strong>和<strong>资源冗余</strong>的问题。</p><ul><li><strong>模块重复打包</strong>：如果多个 <code>Chunk</code> 同时依赖同一个 <code>Module</code>，那么这个 <code>Module</code> 会被重复打包进这些 <code>Chunk</code> 中。</li><li><strong>资源冗余，缓存命中率低</strong>：将所有资源打包成一个文件后，任何改动都会导致客户端重新下载整个代码包，缓存命中率极低。</li></ul><p><code>SplitChunksPlugin</code> 通过一套启发式算法来优化这些问题。</p><h3 id="splitchunksplugin" tabindex="-1">SplitChunksPlugin <a class="header-anchor" href="#splitchunksplugin" aria-label="Permalink to &quot;SplitChunksPlugin&quot;">​</a></h3><p>配置入口：<code>optimization.splitChunks</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  optimization: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    splitChunks: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 1. 分包范围：&#39;all&#39; | &#39;initial&#39; | &#39;async&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      chunks: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;all&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 推荐：对 Initial 和 Async Chunk 都生效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 2. 分包条件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minSize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成 chunk 的最小体积 (bytes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      minChunks: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 会被单独打包的模块的最小【chunk引用次数】，不等于被import次数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      maxAsyncRequests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 按需加载时的最大并行请求数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      maxInitialRequests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入口点的最大并行请求数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 3. 缓存组 (Cache Groups)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 用于为特定资源声明特定的分包规则</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      cacheGroups: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 默认组：处理第三方库</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        defaultVendors: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">node_modules</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配 node_modules</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          priority: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优先级</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          reuseExistingChunk: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 默认组：处理公共模块</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        default: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          minChunks: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 至少被引用 2 次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          priority: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          reuseExistingChunk: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将运行时代码单独拆分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    runtimeChunk: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="配置项详解" tabindex="-1">配置项详解 <a class="header-anchor" href="#配置项详解" aria-label="Permalink to &quot;配置项详解&quot;">​</a></h3><ul><li><p><strong>minChunks</strong>：用于提取公共代码（Common Chunk）。例如 <code>minChunks: 2</code> 表示如果一个模块被 2 个或以上的 Chunk 引用，它就会被提取出来单独打包。</p></li><li><p><strong>maxInitialRequests / maxAsyncRequests</strong>：限制分包数量，防止 HTTP 请求过多。加载一个 Chunk 时，需要同时加载的所有分包（包括其本身）的数量。</p></li><li><p><strong>minSize/maxSize</strong>：限制产物体积，防止产物过【碎】，也避免单个 Chunk 过大，主要通过 <code>minSize</code>， <code>maxSize</code> 配置项来实现。</p></li><li><p><strong>cacheGroups</strong>：为不同文件类型设置不同的规则。比如将所有 <code>node_modules</code> 下的模块统一打包到 <code>vendors</code> 产物，从而实现第三方库与业务代码的分离。</p></li></ul><h3 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h3><ol><li>将第三方库单独打包。</li><li>提取公共代码 (Common)</li><li>独立 Runtime Chunk：配置 <code>optimization.runtimeChunk: true</code>。</li><li>按需加载：对于非首屏路由或组件，使用 <code>import()</code> 语法进行动态导入</li></ol><h2 id="vite-分包策略" tabindex="-1">Vite 分包策略 <a class="header-anchor" href="#vite-分包策略" aria-label="Permalink to &quot;Vite 分包策略&quot;">​</a></h2><h3 id="默认分包策略" tabindex="-1">默认分包策略 <a class="header-anchor" href="#默认分包策略" aria-label="Permalink to &quot;默认分包策略&quot;">​</a></h3><ul><li><strong>CSS 代码分割</strong>：自动提取 CSS 到单独的文件，即一个 <code>chunk</code> 会有一个 <code>*.css</code> 文件。</li><li><strong>动态导入</strong>：使用 <code>import()</code> 动态导入的模块会自动拆分为独立的 <code>chunk</code>。</li><li><strong>第三方库</strong>：在 Rollup 默认配置下，可能会将所有 vendor 依赖打包在一起。</li></ul><h3 id="自定义拆包-manualchunks" tabindex="-1">自定义拆包 (manualChunks) <a class="header-anchor" href="#自定义拆包-manualchunks" aria-label="Permalink to &quot;自定义拆包 (manualChunks)&quot;">​</a></h3><p>可以通过 <code>build.rollupOptions.output.manualChunks</code> 来自定义拆包策略。</p><h4 id="_1-对象配置-简单" tabindex="-1">1. 对象配置（简单） <a class="header-anchor" href="#_1-对象配置-简单" aria-label="Permalink to &quot;1. 对象配置（简单）&quot;">​</a></h4><p>将体积较大的第三方库（如 React、Vue、Lodash）单独拆分为一个 chunk。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  build: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rollupOptions: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      output: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        manualChunks: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 将 React 相关库打包成一个 react-vendor.js</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &#39;react-vendor&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;react-dom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 将 Lodash 打包成 lodash.js</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &#39;lodash&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;lodash-es&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h4 id="_2-函数配置-灵活" tabindex="-1">2. 函数配置（灵活） <a class="header-anchor" href="#_2-函数配置-灵活" aria-label="Permalink to &quot;2. 函数配置（灵活）&quot;">​</a></h4><p>如果依赖项非常多，手动列出所有包名很麻烦。可以使用函数形式来自动拆分。</p><p><strong>示例：将 node_modules 中的每个包单独打包</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  build: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rollupOptions: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      output: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        manualChunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // id 是文件的绝对路径</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (id.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">includes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;node_modules&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 获取包名，例如 node_modules/react/... -&gt; react</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 注意处理 .pnpm 目录结构（如果使用了 pnpm）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vendor&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简单地将所有 node_modules 打包到 vendor 中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="解决循环引用问题" tabindex="-1">解决循环引用问题 <a class="header-anchor" href="#解决循环引用问题" aria-label="Permalink to &quot;解决循环引用问题&quot;">​</a></h3><p>在进行手动拆包（尤其是使用简单的路径匹配）时，有时会遇到 <strong>Circular Dependency</strong>（循环引用）警告。</p><p>这通常是因为简单的拆包逻辑（例如仅根据模块 ID 路径判断）忽略了模块间的<strong>间接依赖</strong>关系。例如，<code>object-assign</code> 可能是 <code>react</code> 的一个间接依赖，如果我们将 <code>react</code> 打包到 <code>react-vendor</code>，但 <code>object-assign</code> 留在了主包或其他 chunk 中，就可能形成循环引用。</p><p>可以手动实现 <code>manualChunks</code> 函数，核心思路是确保<strong>如果一个模块属于某个特定 chunk 的依赖，那么它也应该被打包进这个 chunk</strong>。</p><p>但这比较繁琐，可以使用社区插件 <code>vite-plugin-chunk-split</code> 来开箱即用地解决这个问题。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vite-plugin-chunk-split</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span></span></code></pre></div><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { chunkSplitPlugin } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vite-plugin-chunk-split&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { defineConfig } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vite&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    chunkSplitPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 指定拆包策略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      customSplitting: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 1. 支持填包名</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // \`react\` 和 \`react-dom\` 及其依赖会被自动打包到 \`react-vendor\` chunk 中</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;react-vendor&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;react-dom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 2. 支持正则表达式</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // src 中 components 和 utils 下的所有文件打包为 \`components-util\`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;components-util&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">src</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">components</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">src</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">utils</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div>`,43)])])}const c=i(h,[["render",p]]);export{o as __pageData,c as default};
