import{_ as i,c as a,o as l,a4 as t}from"./chunks/framework.CbmA1wix.js";const n="/assets/style.kfD_Vm-E.png",e="/assets/margin.4IdaGE66.png",h="/assets/flex0.CFdWxXge.jpg",p="/assets/flex-wrap.CInmhJeH.jpg",k="/assets/flex-item.CuJz9_Qx.jpg",r="/assets/grid.C-kbHFlg.jpg",o="/assets/grid-align.Cuk3KPJD.jpg",d="data:image/png;base64,",c="/assets/steps.BgmGpYqC.jpg",E="/assets/transform.B9w-8FEm.jpg",x=JSON.parse('{"title":"CSS","description":"","frontmatter":{"title":"CSS"},"headers":[],"relativePath":"cs/Lang/CSS.md","filePath":"cs/Lang/CSS.md"}'),g={name:"cs/Lang/CSS.md"};function u(y,s,b,F,C,m){return l(),a("div",null,[...s[0]||(s[0]=[t('<h1 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h1><h2 id="层叠值" tabindex="-1">层叠值 <a class="header-anchor" href="#层叠值" aria-label="Permalink to &quot;层叠值&quot;">​</a></h2><p><strong>层叠值</strong>: 当为同一个属性指定了不同的值，浏览器最终选择的一个值。 <strong>重叠规则</strong>：确定层叠值的规则。</p><h3 id="层叠规则" tabindex="-1">层叠规则 <a class="header-anchor" href="#层叠规则" aria-label="Permalink to &quot;层叠规则&quot;">​</a></h3><p>样式的层叠规则为：</p><ol><li>确定样式来源。 样式来源的优先级顺序，位于前面的样式将覆盖后面的</li></ol><p><img src="'+n+`" alt="image"></p><ol start="2"><li>确定CSS选择器。 优先级顺序：ID选择器 &gt; 类选择器 &gt; 标签选择器。 当有相同类型选择器时，则比较数目，多者优先。</li></ol><blockquote><ul><li>伪类选择器和属性选择器归属于类选择器。伪元素选择器同标签选择器。</li><li>通用选择器（＊）和组合器（&gt;、+、~）没有影响。</li></ul></blockquote><p><strong>NOTE：CSS选择器是从右到左进行匹配的。</strong></p><ol start="3"><li>确定源码顺序。 样式声明较晚出现的优先级更高。</li></ol><p>此外，如果一个元素同时处于两个或者更多状态，后声明的状态覆盖其他状态。基于此，对于链接<code>&lt;a&gt;</code>的伪类选择器声明的顺序应为： <code>LOve/HAte法则：link -&gt; visited -&gt; hover -&gt; active</code></p><ol start="4"><li>!important。 可以使得作用的声明优先级最高。多个!important作用则回归前面规则。</li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">blue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !important</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><ul><li>尽量先使用优先级低的选择器，不先用ID选择器。</li><li>不使用!important声明。</li></ul></blockquote><h3 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h3><p>如果元素的某个属性没有层叠值，则可能会继承某个祖先元素属性的值。</p><blockquote><p>不是所有的属性都能被继承。一般跟文本相关的属性可以继承。</p></blockquote><h3 id="特殊值" tabindex="-1">特殊值 <a class="header-anchor" href="#特殊值" aria-label="Permalink to &quot;特殊值&quot;">​</a></h3><p>有两个特殊值可以<mark>赋给任意属性</mark>，用于控制层叠：inherit和initial。 <strong>inherit</strong>：继承其父元素的值。 <strong>initial</strong>：使用默认值（浏览器样式中定义的）。 <strong>unset</strong>：如果其有继承值，则是用，否则使用默认值。</p><blockquote><p>display的默认值是inline。</p></blockquote><p><strong>min-width/max-width</strong></p><ul><li>max-width会覆盖width，即使width是行类样式或者设置了!important。</li><li>min-width会覆盖max-width，当它们冲突时。</li></ul><h3 id="属性简写" tabindex="-1">属性简写 <a class="header-anchor" href="#属性简写" aria-label="Permalink to &quot;属性简写&quot;">​</a></h3><p>使用简写属性时，<mark>被省略的值，会隐式地设置为初始值</mark>。</p><blockquote><p>尽量避免简写font属性。</p></blockquote><h4 id="顺序" tabindex="-1">顺序 <a class="header-anchor" href="#顺序" aria-label="Permalink to &quot;顺序&quot;">​</a></h4><p><strong>方位顺序</strong>：指定某个属性的四个方位时，如<code>margin</code>，其顺序是：上、右、下、左，即顺时针方向。 没有指定的一边会取其对边的值。</p><p><strong>坐标系顺序</strong>：如<code>box-shadow</code>，其顺序为：X轴、Y轴。</p><h2 id="单位" tabindex="-1">单位 <a class="header-anchor" href="#单位" aria-label="Permalink to &quot;单位&quot;">​</a></h2><p>一般指长度单位。</p><p><strong>视口</strong>：浏览器窗口里网页可见部分的边框区域，不包括浏览器的地址栏、工具栏、状态栏。</p><p><strong>物理像素</strong>：设备显示的最小单位。 <strong>设备独立像素</strong>：程序概念，目的是使用时忽略物理像素大小，比如<strong>CSS像素</strong>。 <strong>CSS像素</strong>：设备独立像素的一种，在任意设备上有相同的物理长度。 <strong>PPI</strong>：像素密度，指每英尺多少物理像素。 <strong>DPR</strong>：设备像素比，物理像素/设备独立像素。 <strong>分辨率</strong>：指的是屏幕宽高能显示的<mark>物理像素</mark>点个数。</p><h3 id="绝对单位" tabindex="-1">绝对单位 <a class="header-anchor" href="#绝对单位" aria-label="Permalink to &quot;绝对单位&quot;">​</a></h3><p>在<mark>任意的设备中有相同的长度</mark>，这意味着可以跟物理长度单位进行直接换算。有：px、mm、pt等。96px通常等于一个物理英寸的大小。</p><p>考虑到显示器的分辨率不同，因此<mark>CSS像素不等价于显示器的像素</mark>。</p><h3 id="相对单位" tabindex="-1">相对单位 <a class="header-anchor" href="#相对单位" aria-label="Permalink to &quot;相对单位&quot;">​</a></h3><h4 id="em" tabindex="-1">em <a class="header-anchor" href="#em" aria-label="Permalink to &quot;em&quot;">​</a></h4><p>相对于当前元素的字号，1em等于当前元素的字号。 当当前元素的字号单位为em时，此时其相对的字号是继承的字号。</p><blockquote><p>当设置padding、height、width、border-radius等属性时，使用em会很方便。这些属性会跟着元素字号均匀地缩放。</p></blockquote><h4 id="rem" tabindex="-1">rem <a class="header-anchor" href="#rem" aria-label="Permalink to &quot;rem&quot;">​</a></h4><p>相对于根元素的字号，1rem等于根元素的字号。 当根元素的字号单位为rem或em时，此时其相对的字号是根元素默认的字号。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; // 16</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">px</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="视口单位" tabindex="-1">视口单位 <a class="header-anchor" href="#视口单位" aria-label="Permalink to &quot;视口单位&quot;">​</a></h4><p>相对视口长宽的单位，有vh、vw、vmin、vmax。vh为视口长度的1/100。</p><p>通过结合em可以一定程度上实现响应式策略。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="百分比" tabindex="-1">百分比 <a class="header-anchor" href="#百分比" aria-label="Permalink to &quot;百分比&quot;">​</a></h4><p>对于大部分属性值，百分比值相对于父级元素的相应方向的属性值（主要是高宽），如<code>top</code>，<code>height</code>对应父级<code>height</code>。</p><p>这里的父级元素的高宽指的是<code>content box</code>高宽。</p><p>对于像<code>border-radius</code>、<code>background-size</code>、<code>translate</code>等属性则相对于自身相应方向的值。</p><p>对于下列的属性，其相对于父级元素的<code>width</code>：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">margin、padding、text-index</span></span></code></pre></div><p>更具体的有：</p><ul><li>绝对定位元素的宽高百分比相对于最近的定位祖先元素的padding box的值。</li><li>非绝对定位元素的宽高百分比相对于父元素的content box的值。</li></ul><blockquote><p>一般可以用px设置边框，rem设置字号，em设置其他大部分属性，尤其是内外边距和圆角，百分比设置容器宽度。</p></blockquote><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><ul><li>line-height：当其值无单位时，值相对于该元素字号计算。</li></ul><h2 id="视口" tabindex="-1">视口 <a class="header-anchor" href="#视口" aria-label="Permalink to &quot;视口&quot;">​</a></h2><h3 id="pc端" tabindex="-1">PC端 <a class="header-anchor" href="#pc端" aria-label="Permalink to &quot;PC端&quot;">​</a></h3><p><strong>屏幕</strong>：设备屏幕，单位一般用物理像素。<code>screen.width</code></p><p><strong>窗口</strong>：浏览器展示html文档的那部分，不包括标签栏，但包括滚动条。一般用css像素表示。<code>window.innerWidth</code></p><blockquote><p>显然，缩小浏览器或zoom放大都会使窗口尺寸减小。</p></blockquote><p><strong>视口(viewport)</strong>：可以认为是包含html元素的最顶级块，大小一般略小于窗口，因为不包含滚动条。<code>document.documentElement.clientWidth</code></p><blockquote><p>html元素的实际大小通过<code>document.documentElement.offsetWidth</code>得到。</p></blockquote><p>注意几点：</p><ul><li>一般在pc端上一个CSS像素对应一个物理像素。</li><li>使用zoom放大，实际上使得一个CSS像素对应的物理长度增大，从而对应更多的物理像素。</li><li>当文档宽度大于视口时，浏览器出现水平滚动条。</li></ul><h4 id="事件坐标" tabindex="-1">事件坐标 <a class="header-anchor" href="#事件坐标" aria-label="Permalink to &quot;事件坐标&quot;">​</a></h4><ul><li><code>pageX/Y</code>：相对应<code>&lt;html&gt;</code>元素，CSS像素.</li><li><code>clientX/Y</code>：相对于视口，CSS像素。</li><li><code>screenX/Y</code>：相对于屏幕，物理像素。</li></ul><h3 id="手机端" tabindex="-1">手机端 <a class="header-anchor" href="#手机端" aria-label="Permalink to &quot;手机端&quot;">​</a></h3><p>一般手机的CSS像素大小为400。一般的网页，通常会采用百分比来定长元素，当该网页在手机上浏览时，这些元素就会显得很小。为此，引入其他几个视口概念。</p><p><strong>缩放系数</strong>：<strong>设备宽度 / 视觉视口宽度</strong>。</p><p><strong>布局视口</strong>：包含html元素的最顶级块。大小给定之后不会被改变。<code>document.documentElement.clientWidth</code></p><blockquote><p>顾名思义，css布局所参照的视口既是这个。</p></blockquote><p><strong>视觉视口</strong>：观看文档内容的视口，即整个屏幕。<code>window.innerWidth</code></p><blockquote><p>使用zoom可以改变视觉视口的大小，缩小时视觉视口有更大的px，因而能看到更多的文档内容。放大时会出现水平滚动条。 相应的事件坐标是<code>clientX/Y</code>，因此几乎等同于<code>screenX/Y</code>。</p></blockquote><p><strong>理想视口</strong>：通过将布局视口的大小等于设备的宽度，且缩放系数为1，可以在不同的手机设备上看到一样的内容，<strong>等比缩放</strong>。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><h2 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h2><p>自定义属性。 变量名前面必须有两个连字符，且需在块内声明。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">	--main-font</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Arial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	font-family</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">--main-font</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sans-serif</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); //备用值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>可重新赋值变量值，此时该元素下的子元素将采用新值。</p><h2 id="可视化格式模型" tabindex="-1">可视化格式模型 <a class="header-anchor" href="#可视化格式模型" aria-label="Permalink to &quot;可视化格式模型&quot;">​</a></h2><p>规定了浏览器在页面中如何处理文档树。</p><h3 id="基本概念-1" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念-1" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><p><strong>元素</strong>：指html文档有标签名的元素。</p><p><strong>盒子(box)</strong>：一个格式化结构，根据这种结构来渲染文档。文档中的每一个要渲染的东西都有一个对应的盒子，通常，一个元素对应一个盒子。</p><p><strong>匿名盒子(anonymous boxes)</strong>：指那些没有元素对应的盒子。无法被CSS选择符选中。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;flex&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	I am wrapped in an anonymous box. // 匿名盒子 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;I am in the paragraph&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; // 主盒子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><strong>外表现类型(outer display type)</strong>：指示盒子在文档中如何布局，例如，<strong>块级盒子(block-level box)</strong>，<strong>内联级盒子(inline-level box)</strong>。</p><p><strong>内表现类型(inner display type)</strong>：指示盒子内的元素如何在盒子中布局，如，flex容器盒子。</p><p><strong>盒模型(box model)</strong>：定义了盒子的组成部分及相关含义。</p><p><strong>块(block)</strong>：一个抽象的概念，在文档中的一个独立的区域。</p><p><strong>包含块(containing block)</strong>：盒子的位置和大小有时相对于特定的矩形计算的，这个矩形被称为该元素的包含块。</p><ul><li>根元素被称为”初始包含块“。</li><li>大多数元素的包含块是直接父级元素的<code>content box</code>。</li><li>绝对定位元素的包含块是最近父级定位元素的<code>padding box</code>。</li></ul><p><strong>块容器(block container)</strong>：仅包含块级盒子或内联级盒子的块。</p><p><strong>控制框概念</strong></p><p><strong>块框(block box)</strong>：由块级元素生成，占据一整行，用来包含子box和生成的内容。</p><p>块框同时也是一个<strong>块包含框（<code>Containing Box</code>）</strong>，里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围。</p><p><strong>行内框(inline box)</strong>：一个行内元素生成。行内元素能排在一行，允许左右有其它元素。</p><p><strong>行框盒子(line box)</strong>：包含文本的一行。</p><p><code>display</code>属性值使元素生成不同框：</p><ul><li><code>block</code>：一个块框。</li><li><code>inline</code>：一个或多个的行内框。</li><li><code>inline-block</code>：一个行内级块框。行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）。</li></ul><h3 id="格式化上下文" tabindex="-1">格式化上下文 <a class="header-anchor" href="#格式化上下文" aria-label="Permalink to &quot;格式化上下文&quot;">​</a></h3><p>一个独立且封闭的布局区域，指示外部和内部的布局行为。</p><h4 id="bfc" tabindex="-1">BFC <a class="header-anchor" href="#bfc" aria-label="Permalink to &quot;BFC&quot;">​</a></h4><p>块级格式化上下文</p><ul><li>与外界隔离，不与外界发生外边距折叠，不与外界浮动元素重叠。</li><li>可以自动包含内部的浮动元素。</li></ul><p>触发方式：</p><ul><li>浮动元素。</li><li>overflow值不为 visible。</li><li>display值为 <code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>table</code>、<code>inline-table</code>、<code>flex</code>、<code>inline-flex</code>、<code>grid</code>、<code>inline-grid</code>。</li><li>定位元素，position值为 <code>absolute</code>、<code>fixed</code>。</li></ul><blockquote><p>一般可用<code>display: flow-root</code>来触发，而没有其他副作用。</p></blockquote><h4 id="ifc" tabindex="-1">IFC <a class="header-anchor" href="#ifc" aria-label="Permalink to &quot;IFC&quot;">​</a></h4><p>行级格式化上下文。</p><ul><li>内部的盒子在水平方向一个接一个放置，必要时另起一行。</li><li>IFC高度由内部最高的内联盒子的高度决定。</li></ul><p>触发方式： [TODO]</p><h2 id="盒模型" tabindex="-1">盒模型 <a class="header-anchor" href="#盒模型" aria-label="Permalink to &quot;盒模型&quot;">​</a></h2><p>![image](../assets/box.jpg | 400)</p><p>默认的盒模型（标准盒模型）box-sizing值为<code>content-box</code>，height、width属性为内容的大小。实际元素的大小要加上内边距和边框。</p><p>可以更改其值为<code>border-box</code>（IE盒模型），此时元素的height、width大小包含至边框，但<mark>不包括外边距</mark>。</p><p>全局设置<code>border-box</code>，同时不破坏第三方组件的盒模型设置：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">:root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	box-sizing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">border-box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::before</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	box-sizing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inherit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>设置宽度等大小时，可以通过<code>calc</code>避免魔术数值。</p></blockquote><h3 id="border" tabindex="-1">border <a class="header-anchor" href="#border" aria-label="Permalink to &quot;border&quot;">​</a></h3><ul><li>border-width不支持百分比；border-style的默认值是none；border-color默认值是color色值。</li><li>background背景图片默认相对于padding box定位。</li></ul><h3 id="负边距" tabindex="-1">负边距 <a class="header-anchor" href="#负边距" aria-label="Permalink to &quot;负边距&quot;">​</a></h3><p>元素的外边界由外边（对应外边距）决定，<mark>文档流根据元素的外边界自上或自左将元素依次排列</mark>。 负边距使元素的边界位于元素之内，但不缩小元素的大小。此时，由于文档流的作用机制，有：</p><ul><li>当置左或上边距为负值时，元素表现为向相应方向移动。</li><li>当置右或下边距为负值时，元素不移动，但同一方向的相邻元素向相应方向移动。 <img src="`+e+`" alt="image"></li></ul><p>当元素不指定宽度时，其宽度将填充父级元素，具体地说，是指元素的左右外边界分别贴近父级元素的内边界。此时设置元素左右负边距，效果将是元素左右被拉大。</p><h3 id="外边距折叠" tabindex="-1">外边距折叠 <a class="header-anchor" href="#外边距折叠" aria-label="Permalink to &quot;外边距折叠&quot;">​</a></h3><p>所有相邻的上下<strong>正外边距</strong>会折叠到一起。折叠后取最大的一个外边距。<strong>其余情况不折叠。</strong></p><p>如下，当今div设置上下外边距时，且容器没指定高度时，会使得整个container出现上下外边距。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>下列方法可以防止此种情况：</p><ul><li>对容器使用overflow: auto，此时容器高度包含住div外边距。</li><li>对容器加上边框或者内边距。</li><li>如果容器为浮动元素、内联块、绝对定位或固定定位时，外边距不会在它外面折叠。</li><li>当使用Flexbox或网格布局时，弹性布局内的元素之间不会发生外边距折叠。</li><li>当元素显示为table-cell时不具备外边距属性，因此它们不会折叠。</li></ul><h3 id="元素边距处理" tabindex="-1">元素边距处理 <a class="header-anchor" href="#元素边距处理" aria-label="Permalink to &quot;元素边距处理&quot;">​</a></h3><p>元素之间通常会设置边距，可以使用通用的猫头鹰选择器。 下面选中body内有着相同父级的非第一个子元素。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>body * + *{</span></span>
<span class="line"><span>	margin-top: 1.2em;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h1 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h1><h2 id="伪类与伪元素" tabindex="-1">伪类与伪元素 <a class="header-anchor" href="#伪类与伪元素" aria-label="Permalink to &quot;伪类与伪元素&quot;">​</a></h2><p>在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。为了兼容已有的写法，一些浏览器中也可以使用单冒号来表示伪元素。</p><p>伪类一般匹配元素的一些特殊状态，如hover、link等；而伪元素主要是创建一些不在文档树中的元素。</p><blockquote><p>常见的伪元素有：before、after、first-line、first-letter。</p></blockquote><h2 id="css选择器" tabindex="-1">CSS选择器 <a class="header-anchor" href="#css选择器" aria-label="Permalink to &quot;CSS选择器&quot;">​</a></h2><ul><li>id选择器（#myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div,h1,p）</li><li>后代选择器（h1 p）</li><li>相邻后代选择器（子）选择器（ul &gt; li）</li><li>兄弟选择器（li~a）</li><li>相邻兄弟选择器（li+a）</li><li>属性选择器（a[rel=&quot;external&quot;]）</li><li>伪类选择器（a:hover,li:nth-child）</li><li>伪元素选择器（::before、::after）</li><li>通配符选择器（*)</li></ul><h2 id="display" tabindex="-1">display <a class="header-anchor" href="#display" aria-label="Permalink to &quot;display&quot;">​</a></h2><p>可取的值有：</p><ul><li><strong>block</strong>：块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li><strong>none</strong>：元素不显示，并从文档流中移除。</li><li><strong>inline</strong>：行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li><strong>inline-block</strong>：默认宽度为内容宽度，可以设置宽高，同行显示。</li><li><strong>list-item</strong>：像块类型元素一样显示，并添加样式列表标记。</li><li><strong>table</strong>：此元素会作为块级表格来显示。</li><li><strong>inherit</strong>：规定应该从父元素继承display属性的值。</li></ul><p>当其为none时：</p><ul><li>元素不会被渲染。</li><li><code>&lt;img&gt;</code>元素依然会加载图片。</li><li><code>visibility:hidden</code>同样可以隐藏元素，但元素仍占据空间，虽然不会响应事件。</li></ul><h1 id="布局" tabindex="-1">布局 <a class="header-anchor" href="#布局" aria-label="Permalink to &quot;布局&quot;">​</a></h1><h2 id="浮动" tabindex="-1">浮动 <a class="header-anchor" href="#浮动" aria-label="Permalink to &quot;浮动&quot;">​</a></h2><p>设计初衷：让文字环绕于图片周围。</p><p>脱离普通流，在容器内自动向上浮动，同时可控制其左右浮动方向，直到它的外边界碰到容器边界或另一个浮动边界为止。 对于其他元素，block元素无视float元素，inline元素像流水一样围绕着float元素。</p><p>浮动元素脱离文档流，因此容器不自动包含浮动元素。</p><h3 id="清除浮动" tabindex="-1">清除浮动 <a class="header-anchor" href="#清除浮动" aria-label="Permalink to &quot;清除浮动&quot;">​</a></h3><p>属性clear可控制块级元素被放置在某个位置，在该位置上其左或右没有浮动元素。容器为了包含块级元素而扩大高度，间接包含浮动元素。</p><blockquote><p>不能由于inline元素，因为其始终会围绕浮动元素。当然可用于浮动元素。</p></blockquote><p>类clearfix置于容器中，可使得容器包含浮动元素，且不产生外边距折叠。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.clearfix::before,</span></span>
<span class="line"><span>.clearfix::after{</span></span>
<span class="line"><span>	display: table,</span></span>
<span class="line"><span>	content: &quot;&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>.clearfix::after{</span></span>
<span class="line"><span>	clear: both;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>在IE中，可以在.clearfix中添加<code>zoom:1;</code>触发容器的hasLayout属性，从而包含浮动元素。</p><blockquote><p>元素有hasLayout属性时，它会对自己和可能的子孙元素进行尺寸计算和定位。</p></blockquote><h2 id="弹性布局" tabindex="-1">弹性布局 <a class="header-anchor" href="#弹性布局" aria-label="Permalink to &quot;弹性布局&quot;">​</a></h2><p>给元素添加<code>display: flex</code>，该元素变成了一个弹性容器，它的直接子元素变成了弹性子元素。大体来讲，弹性布局有两大特点：</p><ul><li>弹性容器可以控制子元素在两轴方向上的排列方式。</li><li>子弹性元素可以通过伸缩控制自己的大小，以此适应容器大小，也可控制两轴方向上的位置。</li></ul><p>弹性容器有两个方向，子元素按主轴方向依次排列： <img src="`+h+'" alt="image"></p><p>弹性容器的属性： <img src="'+p+'" alt="image"></p><p>子元素的属性： <img src="'+k+`" alt="image"></p><h2 id="网格布局" tabindex="-1">网格布局 <a class="header-anchor" href="#网格布局" aria-label="Permalink to &quot;网格布局&quot;">​</a></h2><p>可以使用下面定义一个网格容器，同时指定网格的划分。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-template-columns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); //单位任意</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-template-rows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); //内容决定高度</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-gap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> //间隔</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.son1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> / </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> // 占据1、2列</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-row</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: span </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  // 自适应决定哪两行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>基本概念： 网格线的编号从1开始，允许负值。 <img src="`+r+`" alt="image"></p><p>网格布局基本特点：</p><ul><li>同一列的宽度相等，同一行的高度相等。</li><li>子元素可以指定在任意的网格区域放置。</li><li>不指定元素的位置时，元素会按列自适应布局，同时这个布局方式可被指定。</li><li>可以控制子元素在网格区域内的位置（对齐方式）。</li><li>可以控制同一方向的网格轨道的排列方式。（均匀分布之类的）</li></ul><h3 id="命名" tabindex="-1">命名 <a class="header-anchor" href="#命名" aria-label="Permalink to &quot;命名&quot;">​</a></h3><p>为了更加简便的放置元素，可以对某些位置进行命名</p><h4 id="网格线" tabindex="-1">网格线 <a class="header-anchor" href="#网格线" aria-label="Permalink to &quot;网格线&quot;">​</a></h4><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-template-columns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.son</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> / </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; // </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">first</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> column</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="网格区域" tabindex="-1">网格区域 <a class="header-anchor" href="#网格区域" aria-label="Permalink to &quot;网格区域&quot;">​</a></h4><p>可以用(.)空出一个区域</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-template-area</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;title title&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">						&quot;nav .&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">						&quot;main aside&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-template-columns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fr</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-area</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: title; //</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">use</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> first</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> line</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="隐式网格" tabindex="-1">隐式网格 <a class="header-anchor" href="#隐式网格" aria-label="Permalink to &quot;隐式网格&quot;">​</a></h3><p>自动拓展网格轨道。 隐式网格轨道默认大小为auto，即它们会扩展到能容纳网格元素内容。通过grid-auto-columns和grid-auto-rows，可以为隐式网格轨道指定一个大小。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-template-columns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">auto-fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">minmax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-auto-rows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-auto-flow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> //该变子元素布局方式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	grid-area</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: title; //</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">use</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> first</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> line</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><ul><li>auto-fill: 尽可能多地生成轨道，可能留有空白空间。</li><li>auto-fit: 在auth-fill的基础上，让非空的网格轨道扩展，填满可用空间。</li><li>dense: 当有子元素可以放置前面的任意一个网格区域时，就将其放置。这会改变页面元素与源码的对应顺序。</li></ul></blockquote><h3 id="对齐" tabindex="-1">对齐 <a class="header-anchor" href="#对齐" aria-label="Permalink to &quot;对齐&quot;">​</a></h3><p><img src="`+o+'" alt="image"></p><h2 id="定位" tabindex="-1">定位 <a class="header-anchor" href="#定位" aria-label="Permalink to &quot;定位&quot;">​</a></h2><p><strong>定位元素</strong>：position值非<code>static</code>。 定位元素脱离普通流，不对其他元素产生影响。</p><p><strong>固定定位</strong>：<code>fixd</code>。相对于固定的视口定位，可通过<code>left</code>、<code>right</code>决定元素宽度。 <strong>绝对定位</strong>：<code>absolute</code>。相对最近的祖先定位元素（<code>padding box</code>），同样可通过位置决定元素宽度。 <strong>相对定位</strong>：<code>relative</code>。相对原来位置定位。 <strong>粘性定位</strong>：<code>sticky</code>。相对定位和固定定位的结合体。元素随着页面滚动，直到到达视口的某一特定位置。</p><h3 id="z-index" tabindex="-1">z-index <a class="header-anchor" href="#z-index" aria-label="Permalink to &quot;z-index&quot;">​</a></h3><p>z-index只在定位元素上生效。</p><p>层叠顺序：浏览器绘制元素的顺序。层叠顺序越靠前，则越先绘制。一般层叠顺序有：</p><ul><li>源码中先出现的元素靠前。</li><li>定位元素前于非定位元素。</li><li>z-index可改变层叠顺序，值越大，越靠后。</li><li>负值的z-index前与于非定位元素。</li></ul><h4 id="层叠上下文" tabindex="-1">层叠上下文 <a class="header-anchor" href="#层叠上下文" aria-label="Permalink to &quot;层叠上下文&quot;">​</a></h4><p>元素层叠规则的一种形式。</p><ul><li>对于内部而言，根元素的层叠顺序最靠前。</li></ul><blockquote><p>这意味着负z-index的子元素也会覆盖根元素。</p></blockquote><ul><li>对于外部而言，层叠上下文是一个整体，层叠顺序取决于根元素的<code>z-index</code>。</li></ul><blockquote><p>因此，层叠上下文之外的元素无法插入在层叠上下文内的两个元素之间。</p></blockquote><p>有多种方式可以使元素成为层叠上下文：</p><ul><li>根元素、或拥有<code>z-index</code>属性的元素。</li><li>flex或grid容器的子元素。</li></ul><p><img src="'+d+`" alt="image"></p><h1 id="行为" tabindex="-1">行为 <a class="header-anchor" href="#行为" aria-label="Permalink to &quot;行为&quot;">​</a></h1><h2 id="过渡" tabindex="-1">过渡 <a class="header-anchor" href="#过渡" aria-label="Permalink to &quot;过渡&quot;">​</a></h2><p>元素从一个状态平缓过渡到另一种状态。可以添加多个过渡规则，以逗号分隔。</p><ul><li>两个描述状态的类一定要显式声明要过渡的属性。</li><li>过渡的元素占据原来的位置，其变化不影响其他元素（<mark>变化脱离普通流</mark>）。</li><li>脱离普通流的变化不会导致页面重排，其变化的绘制在自己的图层中进行。</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	background-color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: background-color </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> linear</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.a:hover</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	background-color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">//出发后0</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.5s发生过渡</span></span></code></pre></div><h3 id="steps" tabindex="-1">steps() <a class="header-anchor" href="#steps" aria-label="Permalink to &quot;steps()&quot;">​</a></h3><p>过渡函数，其描述的状态变化是一系列非连续性的瞬时阶跃。</p><p><img src="`+c+`" alt="image"></p><blockquote><p>可以用来做旋转菊花</p></blockquote><h2 id="变换" tabindex="-1">变换 <a class="header-anchor" href="#变换" aria-label="Permalink to &quot;变换&quot;">​</a></h2><p>transform属性，改变页面元素的形状和位置。同样的，占据原来的位置，当变化脱离普通流。</p><ul><li>只能用于块内元素。</li><li>可以更改变换基点。</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rotate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">90</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">deg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>主要有四种变换类型： <img src="`+E+`" alt="image"></p><h3 id="三维变换" tabindex="-1">三维变换 <a class="header-anchor" href="#三维变换" aria-label="Permalink to &quot;三维变换&quot;">​</a></h3><h4 id="透视距离" tabindex="-1">透视距离 <a class="header-anchor" href="#透视距离" aria-label="Permalink to &quot;透视距离&quot;">​</a></h4><p>可以将透视距离想象成摄像机和场景之间的距离。透视距离越小，3D效果越强。 可以给单个元素设置透视距离，也可以给容器设置，这样容器内的子元素都有相同的透视距离。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.wrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	perspective</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.son</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">perspective</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rotateX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">40</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">deg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	// 透视放前面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="背面可视性" tabindex="-1">背面可视性 <a class="header-anchor" href="#背面可视性" aria-label="Permalink to &quot;背面可视性&quot;">​</a></h4><p>可通过<code>backface-visibility</code>控制元素背面的可视性。默认可见。</p><blockquote><p>可以又来做两面卡片</p></blockquote><h4 id="transform-style" tabindex="-1">transform-style <a class="header-anchor" href="#transform-style" aria-label="Permalink to &quot;transform-style&quot;">​</a></h4><p>设置容器的子元素是位于 3D 空间中还是平面中。</p><h2 id="动画" tabindex="-1">动画 <a class="header-anchor" href="#动画" aria-label="Permalink to &quot;动画&quot;">​</a></h2><p>以关键帧的形式定义状态的变化过程。 动画中的声明有<mark>更高的优先级来源</mark>。为某个属性添加动画的时候，会覆盖样式表中其他地方应用的样式。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@keyframes</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 0%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	 	transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">translate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	 }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	 100%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	 	transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">translate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	 } </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	animation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">move</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">s</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> linear</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; // </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	//动画播放前就应用动画样式</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	animation-fill-mode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">forwards</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="js动画" tabindex="-1">JS动画 <a class="header-anchor" href="#js动画" aria-label="Permalink to &quot;JS动画&quot;">​</a></h3><p>CSS3 动画：性能上较好；在动画控制上不够灵活，兼容性不好</p><p>JavaScript 动画：控制能力很强，可以单帧的控制、变换，兼容性好，功能强大。</p><blockquote><p>transition基于CSS属性的变化，animation基于元素本身的变化。</p></blockquote><h1 id="兼容" tabindex="-1">兼容 <a class="header-anchor" href="#兼容" aria-label="Permalink to &quot;兼容&quot;">​</a></h1><h2 id="浏览器前缀" tabindex="-1">浏览器前缀 <a class="header-anchor" href="#浏览器前缀" aria-label="Permalink to &quot;浏览器前缀&quot;">​</a></h2><p>浏览器各自的出于实验性目的的CSS属性前缀。</p><ul><li>mozilla 内核：-moz</li><li>webkit 内核： -webkit</li><li>opera 内核： -o</li><li>trident 内核：-ms</li></ul><h2 id="reset-or-normalize" tabindex="-1">reset or normalize <a class="header-anchor" href="#reset-or-normalize" aria-label="Permalink to &quot;reset or normalize&quot;">​</a></h2><p>由于各个浏览器的默认样式不尽相同，导致渲染页面时效果不一致。针对此，有两种方案:</p><p><strong>reset</strong>：将浏览器的默认样式重置，即引入新的样式覆盖默认样式。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">margin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span></code></pre></div><p>缺点：可能引起性能问题，对某些情况下要保留的样式也重置了。</p><p><strong>normalize</strong>： 尽量保留默认样式，同时调整样式使之保持一致并尽可能与现代标准相符合。</p><p>相较于reset，normalize有以下特点：</p><ul><li>保护了有价值的默认值。</li><li>修复了浏览器的 bug。</li><li>Normalize.css 没有复杂的继承链。</li><li>Normalize.css 是模块化的。</li><li>Normalize.css 拥有详细的文档。</li></ul><h2 id="特性查询" tabindex="-1">特性查询 <a class="header-anchor" href="#特性查询" aria-label="Permalink to &quot;特性查询&quot;">​</a></h2><p>询问某个功能是否被浏览器支持。如果支持，则其指定的样式是有效的，否则忽略。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">//前面定义回退方案</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@supports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">grid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><ol><li>浏览器默认的margin和padding不同。</li></ol><blockquote><p>加一个全局的<code>*{margin:0;padding:0;}</code>来统一。</p></blockquote><ol start="2"><li>Chrome中文界面下默认会将小于12px的文本强制按照12px显示。</li></ol><blockquote><p>通过<code>transform:scale(0.5);</code>缩小。</p></blockquote><ol start="3"><li>IOS在<code>overflow:scroll</code>滑动下卡顿。</li></ol><blockquote><p>添加<code>-webkit-overflow-scrolling:touch</code>启用硬件加速。</p></blockquote><h1 id="适配" tabindex="-1">适配 <a class="header-anchor" href="#适配" aria-label="Permalink to &quot;适配&quot;">​</a></h1><h2 id="图像失真" tabindex="-1">图像失真 <a class="header-anchor" href="#图像失真" aria-label="Permalink to &quot;图像失真&quot;">​</a></h2><p>浏览器渲染时，尽可能使得一个物理像素对应一个css像素。</p><p>当一个css像素对应多个物理像素时，例如，在高清屏中，浏览器会采用<strong>平滑处理</strong>的方式填充其他的物理像素。对于单一颜色的图像，例如文字，会使得其看上去更加清晰。对于色彩丰富的图片，则会使其看上去<strong>模糊</strong>。</p><p>当一个物理像素对应多个css像素时，例如，普通屏设备上显示高分辨率图片，这时浏览器会根据这些css像素点上的色值计算实际的色值，从而使图像缺少一些锐利度，或者有点<strong>色差</strong>。</p><h2 id="手机端-1" tabindex="-1">手机端 <a class="header-anchor" href="#手机端-1" aria-label="Permalink to &quot;手机端&quot;">​</a></h2><h3 id="等比缩放" tabindex="-1">等比缩放 <a class="header-anchor" href="#等比缩放" aria-label="Permalink to &quot;等比缩放&quot;">​</a></h3><blockquote><p>相对于设计图进行布局。</p></blockquote><p>将布局视口设为一固定值，例如<code>750px</code>，然后使设备的屏幕视口为相同值。就可以在不同的设备中达到页面同比缩放效果。可以通过设置缩放系数完成。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.screen.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 750</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`&lt;meta name=&quot;viewport&quot; width=&quot;750px&quot; content=&quot;initial-scale=\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scale</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;&gt;\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>设置简单，可以直接根据设计图的尺寸写css。但会将其他不需要缩放的元素缩放，如字体，且大屏幕一行中容纳的元素数量与小屏幕相同。</p><h3 id="rem-vw" tabindex="-1">rem&amp;vw <a class="header-anchor" href="#rem-vw" aria-label="Permalink to &quot;rem&amp;vw&quot;">​</a></h3><blockquote><p>相对于屏幕进行布局。</p></blockquote><p><strong>rem</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, initial-scale=1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.documentElement.style.fontSize =\`\${window.screen.width / 7.5}px\`.</span></span></code></pre></div><h1 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h1><h2 id="li空白" tabindex="-1">li空白 <a class="header-anchor" href="#li空白" aria-label="Permalink to &quot;li空白&quot;">​</a></h2><p>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。这会使得下面的<code>li</code>元素之间产生一个空白。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;display:inline-block;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;1&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; // 换行了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;display:inline-block;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>可以这样子解决：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">letter-spacing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">letter-spacing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span></code></pre></div><h1 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h1><h2 id="加载" tabindex="-1">加载 <a class="header-anchor" href="#加载" aria-label="Permalink to &quot;加载&quot;">​</a></h2><ul><li>css压缩。</li><li>用<code>link</code>代替<code>@import</code>。</li></ul><h2 id="选择器" tabindex="-1">选择器 <a class="header-anchor" href="#选择器" aria-label="Permalink to &quot;选择器&quot;">​</a></h2><p><strong>关键选择器</strong>：选择器的最后面的部分。</p><ul><li>尽量不用后代选择器，否则浏览器会遍历所有子元素来确定是否符合条件。</li><li>避免使用通配规则。</li><li>如果ID选择器作为其关键选择器，则不要再添加规则。</li><li>尽量少用标签进行选择，而是用class。</li><li>选择器优化嵌套，尽量避免层级过深。</li></ul><h2 id="渲染" tabindex="-1">渲染 <a class="header-anchor" href="#渲染" aria-label="Permalink to &quot;渲染&quot;">​</a></h2><ul><li>少用浮动、定位。</li><li>减少页面重排、重绘。</li><li>去除空规则。</li><li>属性值为0时，不加单位。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前，标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>正确使用display的属性。</li></ul><blockquote><p>由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p></blockquote><ul><li>不滥用web字体。</li></ul><h2 id="可维护性、健壮性" tabindex="-1">可维护性、健壮性 <a class="header-anchor" href="#可维护性、健壮性" aria-label="Permalink to &quot;可维护性、健壮性&quot;">​</a></h2><ul><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ul><h1 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h1><h2 id="处理器" tabindex="-1">处理器 <a class="header-anchor" href="#处理器" aria-label="Permalink to &quot;处理器&quot;">​</a></h2><p><strong>预处理器</strong>：定义了一种语言，可以将其编译为CSS语言。</p><blockquote><p>LESS、Sass、Stylus</p></blockquote><p><strong>后处理器</strong>：对CSS进行额外的自动化处理，如添加浏览器前缀等。</p><blockquote><p>Autoprefixer</p></blockquote><h2 id="css-sprites" tabindex="-1">CSS Sprites <a class="header-anchor" href="#css-sprites" aria-label="Permalink to &quot;CSS Sprites&quot;">​</a></h2><p>将多张图片合并成一张大图片，减少网络请求。利用CSS定位到所需的图片中。</p><p>优点：</p><ul><li>减少HTTP请求数。</li><li>增加图片信息重复度，提高压缩比，减少图片大小。</li><li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现。</li></ul><p>缺点：</p><ul><li>图片合并麻烦。</li><li>维护麻烦，修改一个图片可能需要重新布局整张图片。</li></ul><h1 id="资源" tabindex="-1">资源 <a class="header-anchor" href="#资源" aria-label="Permalink to &quot;资源&quot;">​</a></h1><ul><li><a href="https://animista.net/" target="_blank" rel="noreferrer">动画animista</a></li></ul>`,301)])])}const f=i(g,[["render",u]]);export{x as __pageData,f as default};
