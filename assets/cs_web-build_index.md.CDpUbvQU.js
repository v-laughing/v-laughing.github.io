import{_ as i,c as t,o as a,a4 as e}from"./chunks/framework.DWze_QZm.js";const k=JSON.parse('{"title":"Web 构建工具发展史","description":"","frontmatter":{"title":"Web 构建工具发展史"},"headers":[],"relativePath":"cs/web-build/index.md","filePath":"cs/web-build/index.md"}'),n={name:"cs/web-build/index.md"};function l(r,s,o,h,p,d){return a(),t("div",null,[...s[0]||(s[0]=[e(`<h1 id="web-构建工具发展史" tabindex="-1">Web 构建工具发展史 <a class="header-anchor" href="#web-构建工具发展史" aria-label="Permalink to &quot;Web 构建工具发展史&quot;">​</a></h1><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to &quot;目录&quot;">​</a></h2><ul><li><a href="./module.html">前端模块化发展</a></li><li><a href="./webpack.html">Webpack 原理与实践</a></li><li><a href="./vite.html">Vite 原理与实践</a></li></ul><h2 id="web-构建工具发展综述" tabindex="-1">Web 构建工具发展综述 <a class="header-anchor" href="#web-构建工具发展综述" aria-label="Permalink to &quot;Web 构建工具发展综述&quot;">​</a></h2><p>Web 前端开发从最初简单的静态页面，发展到如今复杂的大型单页应用（SPA），构建工具也随之经历了从无到有、从简单到复杂的演进过程。</p><h3 id="_1-刀耕火种时代-无构建工具" tabindex="-1">1. 刀耕火种时代（无构建工具） <a class="header-anchor" href="#_1-刀耕火种时代-无构建工具" aria-label="Permalink to &quot;1. 刀耕火种时代（无构建工具）&quot;">​</a></h3><p>在早期的 Web 开发中，我们直接通过 <code>&lt;script&gt;</code> 标签引入 JavaScript 文件。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jquery.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;utils.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><strong>存在的问题：</strong></p><ul><li><strong>全局作用域污染</strong>：所有变量都在全局作用域，容易发生冲突。</li><li><strong>依赖管理困难</strong>：必须手动保证加载顺序（如 <code>main.js</code> 依赖 <code>jquery.js</code>，则 jQuery 必须先加载）。</li><li><strong>请求过多</strong>：每个文件对应一个 HTTP 请求，影响页面加载性能。</li></ul><h3 id="_2-任务运行器时代-task-runners" tabindex="-1">2. 任务运行器时代（Task Runners） <a class="header-anchor" href="#_2-任务运行器时代-task-runners" aria-label="Permalink to &quot;2. 任务运行器时代（Task Runners）&quot;">​</a></h3><p>随着 Node.js 的发布，出现了基于任务的构建工具，代表作是 <strong>Grunt</strong> and <strong>Gulp</strong>。</p><p>它们主要解决的是<strong>自动化</strong>的问题，将繁琐的重复工作（如压缩 CSS/JS、编译 Less/Sass、图片压缩）自动化。</p><ul><li><strong>Grunt</strong>：基于配置（Configuration），通过插件完成任务，配置较为繁琐，IO 操作多（读写临时文件）。</li><li><strong>Gulp</strong>：基于流（Stream），通过管道（Pipe）连接任务，配置简洁，性能更好（内存处理）。</li></ul><p><strong>局限性：</strong> 它们本质上是任务调度器，并没有从根本上解决模块化和依赖管理的问题。</p><h3 id="_3-模块化与打包工具时代-module-bundlers" tabindex="-1">3. 模块化与打包工具时代（Module Bundlers） <a class="header-anchor" href="#_3-模块化与打包工具时代-module-bundlers" aria-label="Permalink to &quot;3. 模块化与打包工具时代（Module Bundlers）&quot;">​</a></h3><p>前端逻辑日益复杂，模块化成为刚需。CommonJS（Node.js）、AMD（RequireJS）、CMD（SeaJS）等规范相继出现。</p><p><strong>Webpack</strong> 应运而生，成为了这一时代的霸主。</p><ul><li><strong>核心理念</strong>：一切皆模块（JavaScript, CSS, Images, Fonts）。</li><li><strong>功能</strong>：通过 Loader 转换文件，通过 Plugin 扩展功能，构建依赖图谱（Dependency Graph），将所有资源打包成一个或多个 Bundle。</li><li><strong>优势</strong>：强大的生态、代码分割（Code Splitting）、Tree Shaking（虽然早期支持有限）。</li><li><strong>劣势</strong>：配置极其复杂，随着项目增大，构建速度显著变慢。</li></ul><p>同期的还有 <strong>Rollup</strong>（专注于 ES Module 打包，生成的代码更简洁，适合库开发）和 <strong>Parcel</strong>（主打零配置）。</p><h3 id="_4-现代构建工具时代-esm-native-tools" tabindex="-1">4. 现代构建工具时代（ESM &amp; Native Tools） <a class="header-anchor" href="#_4-现代构建工具时代-esm-native-tools" aria-label="Permalink to &quot;4. 现代构建工具时代（ESM &amp; Native Tools）&quot;">​</a></h3><p>随着浏览器对 ES Modules (ESM) 的原生支持，以及项目规模的进一步扩大，Webpack 的性能瓶颈（尤其是开发环境冷启动和热更新 HMR）日益突出。</p><p>新一代工具采用了两个核心策略来提升性能：</p><ol><li><strong>No-Bundle（利用浏览器原生 ESM）</strong></li><li><strong>使用高性能语言（Go/Rust）重写底层工具</strong></li></ol><h4 id="vite-the-next-generation-frontend-tooling" tabindex="-1">Vite (The Next Generation Frontend Tooling) <a class="header-anchor" href="#vite-the-next-generation-frontend-tooling" aria-label="Permalink to &quot;Vite (The Next Generation Frontend Tooling)&quot;">​</a></h4><ul><li><strong>开发环境</strong>：利用浏览器原生 ESM，源文件无需打包，按需加载。服务器启动极快，HMR 速度与应用规模无关。</li><li><strong>生产环境</strong>：使用 Rollup 进行打包，保证兼容性和优化。</li><li><strong>底层依赖</strong>：大量使用 <strong>Esbuild</strong>（Go 编写）进行预构建和转换，速度是 JS 工具的 10-100 倍。</li></ul><h4 id="其他高性能工具" tabindex="-1">其他高性能工具 <a class="header-anchor" href="#其他高性能工具" aria-label="Permalink to &quot;其他高性能工具&quot;">​</a></h4><ul><li><strong>Esbuild</strong>：Go 编写的构建工具，速度极快，但插件生态和构建特性不如 Webpack/Rollup 丰富，常作为底层工具被其他框架集成（如 Vite）。</li><li><strong>SWC</strong>：Rust 编写的 JS/TS 编译器，旨在替代 Babel，Next.js 目前主力使用。</li><li><strong>Turbopack</strong>：Vercel 团队推出的 Webpack 继任者，使用 Rust 编写，旨在提供极致的构建速度。</li></ul>`,28)])])}const u=i(n,[["render",l]]);export{k as __pageData,u as default};
