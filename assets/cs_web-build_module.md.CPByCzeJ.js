import{_ as i,c as a,o as n,a4 as t}from"./chunks/framework.DdddRsJj.js";const E=JSON.parse('{"title":"前端模块化发展","description":"","frontmatter":{"title":"前端模块化发展"},"headers":[],"relativePath":"cs/web-build/module.md","filePath":"cs/web-build/module.md"}'),e={name:"cs/web-build/module.md"};function l(h,s,p,k,o,r){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="前端模块化发展" tabindex="-1">前端模块化发展 <a class="header-anchor" href="#前端模块化发展" aria-label="Permalink to &quot;前端模块化发展&quot;">​</a></h1><p>自 2009 年 Node.js 诞生以来，前端模块化经历了一系列的演进，从最初的无模块化标准，到 CommonJS、AMD、CMD、UMD，最终发展到如今的 ES Module (ESM) 标准。</p><h2 id="无模块化标准阶段" tabindex="-1">无模块化标准阶段 <a class="header-anchor" href="#无模块化标准阶段" aria-label="Permalink to &quot;无模块化标准阶段&quot;">​</a></h2><p>在模块化标准诞生之前，前端开发主要依靠以下几种手段进行代码组织，但都存在明显的缺陷。</p><ul><li><strong>文件划分</strong>：将应用的状态和逻辑分散到不同的文件中，通过 HTML 的 <code>script</code> 标签引入。</li><li><strong>命名空间</strong>：通过将变量挂载到全局对象（如 <code>window</code>）的特定属性下，形成命名空间。</li><li><strong>IIFE (立即执行函数)</strong>：使用立即执行函数表达式（IIFE）创建私有作用域。</li></ul><p>这些方式在一定程度上解决了<mark>全局作用域污染</mark>的问题，但依然没有解决<mark>模块加载和依赖管理</mark>的问题。</p><h2 id="模块化规范的出现" tabindex="-1">模块化规范的出现 <a class="header-anchor" href="#模块化规范的出现" aria-label="Permalink to &quot;模块化规范的出现&quot;">​</a></h2><p>为了解决模块加载和依赖管理问题，业界涌现出了多种规范。</p><h3 id="commonjs-规范" tabindex="-1">CommonJS 规范 <a class="header-anchor" href="#commonjs-规范" aria-label="Permalink to &quot;CommonJS 规范&quot;">​</a></h3><p>CommonJS 是 Node.js 采用的模块规范，主要用于<strong>服务端</strong>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导出</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  getData,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./module-a.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>CommonJS 约定以同步的方式进行模块加载，在服务端（本地文件读取）没有问题，但在浏览器端（网络请求）会导致页面阻塞，因此<strong>不适合直接用于浏览器</strong>（需要 Browserify 等工具转换）。</p><h3 id="amd-规范-asynchronous-module-definition" tabindex="-1">AMD 规范 (Asynchronous Module Definition) <a class="header-anchor" href="#amd-规范-asynchronous-module-definition" aria-label="Permalink to &quot;AMD 规范 (Asynchronous Module Definition)&quot;">​</a></h3><p>专为<strong>浏览器</strong>设计的异步模块定义规范。代表库：<strong>RequireJS</strong>。异步加载，依赖前置（定义模块时声明依赖）。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义模块</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">define</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./print&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">printModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  printModule.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>语法相对复杂，阅读和书写体验不佳。</p><h3 id="cmd-与-umd" tabindex="-1">CMD 与 UMD <a class="header-anchor" href="#cmd-与-umd" aria-label="Permalink to &quot;CMD 与 UMD&quot;">​</a></h3><p>CMD：由淘宝 SeaJS 提出，类似于 AMD 但推崇<strong>依赖就近</strong>（用到时再 require）。</p><p><strong>UMD</strong> (Universal Module Definition)：兼容 CommonJS、AMD 和全局变量的通用模式，<mark>常用于库的打包</mark>，使其能在各种环境中运行。</p><h2 id="es6-module-esm" tabindex="-1">ES6 Module (ESM) <a class="header-anchor" href="#es6-module-esm" aria-label="Permalink to &quot;ES6 Module (ESM)&quot;">​</a></h2><p>ECMAScript 官方提出的标准化模块规范，旨在成为<mark>浏览器和服务器</mark>通用的模块解决方案。</p><p><code>import</code> 和 <code>export</code> 语句必须位于模块顶层，这使得构建工具可以在编译时进行<strong>Tree Shaking</strong>（摇树优化），去除未使用的代码。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// module-a.js (导出)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> methodA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js (导入)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { methodA } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./module-a.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">methodA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="浏览器中使用" tabindex="-1">浏览器中使用 <a class="header-anchor" href="#浏览器中使用" aria-label="Permalink to &quot;浏览器中使用&quot;">​</a></h3><p>在 <code>&lt;script&gt;</code> 标签中添加 <code>type=&quot;module&quot;</code> 属性：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./main.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="node-js-中使用" tabindex="-1">Node.js 中使用 <a class="header-anchor" href="#node-js-中使用" aria-label="Permalink to &quot;Node.js 中使用&quot;">​</a></h3><p>Node.js (v12.20+) 原生支持 ESM。可以通过以下方式启用：</p><ol><li>文件名后缀改为 <code>.mjs</code>。</li><li>在 <code>package.json</code> 中设置 <code>&quot;type&quot;: &quot;module&quot;</code>。</li></ol>`,29)])])}const c=i(e,[["render",l]]);export{E as __pageData,c as default};
