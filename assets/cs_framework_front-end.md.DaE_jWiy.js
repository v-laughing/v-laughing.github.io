import{_ as o,c as e,o as r,a4 as t}from"./chunks/framework.CBsUJNCA.js";const a="/assets/mvc.DIsxtKGD.png",l="/assets/mvp.BBzPOTF0.png",i="/assets/mvvm.98dPpM9W.png",_=JSON.parse('{"title":"前端","description":"","frontmatter":{"title":"前端","sidebar":"auto","publish":true},"headers":[],"relativePath":"cs/framework/front-end.md","filePath":"cs/framework/front-end.md"}'),s={name:"cs/framework/front-end.md"},n=t('<h1 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h1><h2 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-label="Permalink to &quot;MVVM&quot;">​</a></h2><p>MVC、MVP 和 MVVM 是三种常见的<strong>软件架构设计模式</strong>，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。</p><p><strong>MVC</strong></p><ul><li>View 负责页面的显示逻辑；Model 负责存储页面的业务数据；Controller负责用户与应用的响应操作。</li><li>View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。</li><li>用户与页面的交互会触发Controller 中的事件触发器，接着其调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</li></ul><p><img src="'+a+'" alt="image"></p><p><strong>MVP</strong> MVC中 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。通过在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。</p><p><img src="'+l+'" alt="image"></p><p><strong>MVVM</strong></p><p>基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p><p><img src="'+i+'" alt="image"></p><h2 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;webpack&quot;">​</a></h2><p>简化页面依赖的管理，通过将页面打包为一个文件来降低页面加载时请求的资源数。</p><p>将所有的资源视为一个模块，把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。</p><p>Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。</p><p><strong>Entry</strong>： webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。</p><p><strong>Output</strong>：告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。</p><p><strong>loader</strong>： webpack 的编译器，将各种类型的资源转换成 JavaScript 模块，可以指定处理哪些文件或通过什么工具预处理哪些文件。</p><p><strong>Plugins</strong>：包括打包、优化、压缩、搭建服务器等等。</p><blockquote><p>配置很麻烦</p></blockquote><h2 id="单页面应用" tabindex="-1">单页面应用 <a class="header-anchor" href="#单页面应用" aria-label="Permalink to &quot;单页面应用&quot;">​</a></h2><p>只有一个 HTML 页面，利用 JS 动态的变换 HTML 的内容，从而来模拟多个视图间跳转。</p><p><strong>优点</strong>：用户体验良好，维护简单。</p><p><strong>缺点</strong>：不利于SEO的优化；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。</p><p>为了在前端实现路由跳转，应该满足：</p><ul><li>改变 url 且不加载页面。</li><li>浏览器记录url变化历史。</li><li>可以监听到 url 的变化。</li></ul><h3 id="前端路由实现" tabindex="-1">前端路由实现 <a class="header-anchor" href="#前端路由实现" aria-label="Permalink to &quot;前端路由实现&quot;">​</a></h3><h4 id="hash模式" tabindex="-1">hash模式 <a class="header-anchor" href="#hash模式" aria-label="Permalink to &quot;hash模式&quot;">​</a></h4><p>在浏览器中符号“#”及其后面的字符称之为hash，用window.location.hash读取。</p><p>hash虽然在URL中，但不被包括在HTTP请求中。</p><p>优点：</p><ul><li>实现简单，兼容性好（兼容到<code>ie8</code>）</li><li>不需要服务器端进行任何设置和开发</li><li>除了资源加载和<code>ajax</code>请求以外，不会发起其他请求</li></ul><p>缺点</p><ul><li>对于部分需要重定向的操作，后端无法获取<code>hash</code>部分内容，导致后台无法取得<code>url</code>中参数。</li><li>服务器端无法准确跟踪前端路由信息。</li><li>对于需要锚点功能的需求会与目前路由机制冲突</li></ul><h4 id="history模式" tabindex="-1">history模式 <a class="header-anchor" href="#history模式" aria-label="Permalink to &quot;history模式&quot;">​</a></h4><p>[[browser#history | 见history]]</p><p>优点</p><ul><li>对于重定向过程中不会丢失<code>url</code>中的参数。后端可以拿到这部分数据。</li><li>后端可以准确跟踪路由信息。</li><li>可以使用<code>history.state</code>来获取当前<code>url</code>对应的状态信息。</li></ul><p>缺点</p><ul><li>兼容性不如<code>hash</code>路由(只兼容到<code>IE10</code>)</li><li>需要后端支持，每次返回<code>html</code>文档。</li></ul><p>两者最大的区别在于<mark>服务端能否拿到路由信息</mark>。</p><h1 id="框架设计" tabindex="-1">框架设计 <a class="header-anchor" href="#框架设计" aria-label="Permalink to &quot;框架设计&quot;">​</a></h1><h2 id="数据绑定" tabindex="-1">数据绑定 <a class="header-anchor" href="#数据绑定" aria-label="Permalink to &quot;数据绑定&quot;">​</a></h2><p>实现<strong>MVVM</strong>框架的一个问题是解决<strong>数据模型(model)</strong> 与 <strong>视图(view)</strong> 之间的数据交互。<strong>view</strong>=&gt;<strong>model</strong>的过程可通过<strong>DOM事件回调</strong>实现。<strong>model</strong>=&gt;<strong>view</strong>的过程称为<strong>变化侦听</strong>，一般有以下几种实现方式。</p><p><strong>脏值检查</strong>：对比新旧数据，来决定是否更新视图。</p><p>最简单的实现方式是用定时任务<strong>轮询</strong>来检测数据变动。<code>angular.js</code>则只在某些事件被触发时才会进行脏值检查。比如，</p><ul><li>DOM事件，如用户输入文本，点击按钮等。</li><li>XHR响应事件。</li><li>浏览器Location变更事件。</li><li>Timer事件。</li></ul><hr><p><strong>数据劫持</strong>：在访问或修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。</p><p>在<strong>JS</strong>中可通过<code>Object.defineProperty</code>或<code>Proxy</code>的方式实现对对象的数据拦截。</p><hr><p><strong>发布者-订阅者模式</strong>：#TODO</p>',52),p=[n];function d(c,h,g,u,m,b){return r(),e("div",null,p)}const V=o(s,[["render",d]]);export{_ as __pageData,V as default};
