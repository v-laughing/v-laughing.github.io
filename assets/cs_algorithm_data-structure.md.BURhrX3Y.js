import{_ as e}from"./chunks/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.CIudCsXe.js";import{_ as r,c as t,o as i,a4 as l}from"./chunks/framework.DdddRsJj.js";const o="/assets/br-tree.BE705SR5.png",s="/assets/btree.BXrUoa44.png",p="data:image/png;base64,",n="/assets/beba612e-dc5b-4fc2-869d-0b23408ac90a.ITOc9KeD.png",h="/assets/0ea37ee2-c224-4c79-b895-e131c6805c40.U09mA_bL.png",c="/assets/skiplist.BXyGVpF7.png",m="data:image/jpeg;base64,",P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"cs/algorithm/data-structure.md","filePath":"cs/algorithm/data-structure.md"}'),d={name:"cs/algorithm/data-structure.md"};function u(b,a,g,_,q,k){return i(),t("div",null,[...a[0]||(a[0]=[l('<h2 id="红黑树" tabindex="-1">红黑树 <a class="header-anchor" href="#红黑树" aria-label="Permalink to &quot;红黑树&quot;">​</a></h2><p>改进的二叉查找树，可以保证插入、删除、查找操作的最坏时间复杂度都为 O(logn)。</p><blockquote><p>二叉查找树：左子树为空或其所有结点的值均小于它的根结点的值，同时右子树为空或其所有结点的值均大于等于它的根结点的值。最坏查找时间O(n)。</p></blockquote><p>相比<strong>平衡二叉树(AVL树)</strong>，其所有节点的左右子树高度差的绝对值不超过1，为了在插入或删除操作时保持树性质而进行的<mark>旋转操作的时间要短点</mark>。</p><h3 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构&quot;">​</a></h3><p>通过对结点引入一个标记（颜色），并且使其遵循一定的约束，来使得树尽可能接近平衡树。</p><p>有以下5个约束：</p><ol><li>每个结点要么是红色，要么是黑色；</li><li>根结点永远是黑色的；</li><li>所有的NULL结点都是是黑色的；</li><li>每个红色结点的两个子结点一定都是黑色；</li><li>从任一结点到其子树中每个叶子结点的路径都包含相同数量的黑色结点；</li></ol><p><img src="'+o+'" alt="image"></p><h2 id="多路平衡查找树-b树" tabindex="-1">多路平衡查找树（B树） <a class="header-anchor" href="#多路平衡查找树-b树" aria-label="Permalink to &quot;多路平衡查找树（B树）&quot;">​</a></h2><p><strong>树+有序链表</strong></p><p>一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。常被应用在数据库和文件系统的实现上。</p><h3 id="结构-1" tabindex="-1">结构 <a class="header-anchor" href="#结构-1" aria-label="Permalink to &quot;结构&quot;">​</a></h3><p><strong>结点是有序链表</strong> 每一个内部结点包含一定数量的键，键包含键值及数据，且将结点的子树分开。</p><p><strong>树为查找树</strong> 每个键的左子树的值均小于当前键值，右子树的值均大于当前键值。</p><p>如果B树的每个结点最多有m个子结点，则称此树为m阶B树。</p><p>对于一个阶数为 m 的 B-Tree，它有如下性质：</p><ul><li>每个结点最多有 m 个子结点；</li><li>每个非叶子结点（根结点除外）至少含有 m/2 个子结点；</li><li>如果根结点不是叶子结点，那么根结点至少有两个子结点；</li><li>对于一个非叶子结点而言，它最多能存储 m-1 个键。</li></ul><h3 id="构造过程" tabindex="-1">构造过程 <a class="header-anchor" href="#构造过程" aria-label="Permalink to &quot;构造过程&quot;">​</a></h3><p><strong>查找、插入、分裂</strong> 对于将要插入的一个键，从根结点开始查找，找到要插入的树结点，根据是否满足B树性质判断是否要对此结点执行分裂操作。</p><p><img src="'+s+'" alt="image"></p><h3 id="b-tree" tabindex="-1">B+tree <a class="header-anchor" href="#b-tree" aria-label="Permalink to &quot;B+tree&quot;">​</a></h3><p>B+Tree来源自B-Tree，与B-Tree的主要不同点在于：</p><ul><li>B+Tree的所有数据存储在叶子结点中，非叶子结点通过键值充当路标指引。非叶子结点的键值是叶子结点的一部分拷贝。</li><li>叶子结点中存有一个指针指向兄弟结点</li></ul><p><img src="'+p+'" alt="image"></p><h3 id="对比" tabindex="-1">对比 <a class="header-anchor" href="#对比" aria-label="Permalink to &quot;对比&quot;">​</a></h3><p>存储引擎存储数据的最小单元是页。因此在索引树结构中，一个结点的大小通常是一个数据页的整数倍。</p><p>对于同样的数据量大小，相对于B-Tree，由于B+Tree的非叶子结点不需要存储数据，使得B+Tree的阶树更大，树高更小。</p><p>由于树的插入、查找、删除的时间复杂度与树的高度成正相关，因此大部分存储引擎会采用B+Tree结构来构造索引。</p><h2 id="跳跃表" tabindex="-1">跳跃表 <a class="header-anchor" href="#跳跃表" aria-label="Permalink to &quot;跳跃表&quot;">​</a></h2><p><strong>链表+二分查找</strong> 一种随机化的数据结构，查找、删除、添加等操作都可以在<mark>对数期望时间</mark>下完成。</p><p>在一般的链表与数组中，快速查找与快速插入或删除是矛盾的。跳跃表可以解决这种矛盾。</p><h3 id="结构-2" tabindex="-1">结构 <a class="header-anchor" href="#结构-2" aria-label="Permalink to &quot;结构&quot;">​</a></h3><p>基于多指针有序链表实现的，可以看成多个有序链表。每个结点维护了多个层级的下一个结点的指针。</p><p><img src="'+n+'" alt="avatar | 600"><br></p><p>在查找时，从上层指针开始查找，找到对应的区间之后，再从当前结点的指向下一层的指针去查找。下图演示了查找 22 的过程。</p><p><img src="'+h+'" alt="avatar | 600"><br></p><h3 id="构造过程-1" tabindex="-1">构造过程 <a class="header-anchor" href="#构造过程-1" aria-label="Permalink to &quot;构造过程&quot;">​</a></h3><p>维护相邻两层链表上结点个数严格的 2:1 的对应关系会使得插入的时间复杂度为O(n)。因此，一般采用随机层数的方法插入结点：插入结点时，随机生成层数P，将该结点放置在1-P层中。</p><p><img src="'+c+'" alt="image"></p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现；</li><li>支持无锁操作。</li></ul><h2 id="trie树" tabindex="-1">Trie树 <a class="header-anchor" href="#trie树" aria-label="Permalink to &quot;Trie树&quot;">​</a></h2><p><strong>树+字典</strong>：[[../leetcode/tree#Trie| 实现]]</p><p><img src="'+e+'" alt="avatar"><br> 前缀树或字典树，一个确定有限状态自动机。 它有3个基本性质：</p><ul><li>根节点不包含字符，除根节点外每一个节点都<mark>只包含一个字符</mark>。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><p>可以用于<mark>搜索提示</mark>，代码补全。</p><h2 id="布隆过滤器" tabindex="-1">布隆过滤器 <a class="header-anchor" href="#布隆过滤器" aria-label="Permalink to &quot;布隆过滤器&quot;">​</a></h2><p>检查值是 “可能在集合中” 还是 “绝对不在集合中”。</p><p>其基本思想是：</p><ul><li>当一个元素被加入集合时，通过<strong>K个散列函数</strong>将这个元素映射成一个<strong>位数组</strong>中的K个点，把它们置为1。</li><li>检索时，检查该值被散列函数映射的<strong>K个点</strong>：如果这些点存在一个0，则被检元素一定不存在；如果都是1，则被检元素可能存在。</li></ul><p><img src="'+m+'" alt="image"></p><h3 id="优点与缺点" tabindex="-1">优点与缺点 <a class="header-anchor" href="#优点与缺点" aria-label="Permalink to &quot;优点与缺点&quot;">​</a></h3><ul><li>存储空间和插入/查询时间都是常数。</li><li>存在一定的误算率。</li></ul>',55)])])}const T=r(d,[["render",u]]);export{P as __pageData,T as default};
