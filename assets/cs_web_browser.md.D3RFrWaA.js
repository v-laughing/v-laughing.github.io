import{_ as i,c as s,o as e,a4 as t}from"./chunks/framework.DdddRsJj.js";const l="data:image/png;base64,",o="/assets/html-parase.dOpoN0G2.png",n="/assets/browser_parse_html.BOAsl7yG.png",r="/assets/browser_parse_rendertree.DAAJbHJi.png",h="/assets/js_load.P38yZnZs.png",m=JSON.parse('{"title":"浏览器","description":"","frontmatter":{"title":"浏览器"},"headers":[],"relativePath":"cs/web/browser.md","filePath":"cs/web/browser.md"}'),p={name:"cs/web/browser.md"};function d(c,a,k,g,u,b){return e(),s("div",null,[...a[0]||(a[0]=[t('<h1 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h1><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示服务器发送过来的网络资源。</p><h2 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构&quot;">​</a></h2><p>一般构成：</p><ul><li><strong>用户界面</strong>：包括地址栏、前进/后退按钮、书签菜单等。</li><li><strong>浏览器引擎</strong> ：在用户界面和渲染引擎之间传送指令。</li><li><strong>渲染引擎</strong> ：负责显示请求的内容。</li><li><strong>用户界面后端</strong>：用于绘制基本的窗口小部件，比如组合框和窗口。</li><li><strong>JavaScript 解释器</strong>：用于解析和执行 JavaScript 代码。（通常也称JS引擎）</li><li><strong>数据存储</strong>：持久层。</li></ul><p><img src="'+l+`" alt="image"></p><p>更概括的，可以分为外壳与内核：</p><ul><li><strong>shell</strong>：外壳。例如菜单，工具栏等。提供给用户界面操作，参数设置等等。调用内核来实现各种功能。</li><li><strong>内核</strong>：一般着重指渲染引擎，有时也包含JS引擎。</li></ul><h2 id="执行架构" tabindex="-1">执行架构 <a class="header-anchor" href="#执行架构" aria-label="Permalink to &quot;执行架构&quot;">​</a></h2><p>浏览器一般会划分为以下几个进程：</p><ul><li>Browser进程：浏览器的主进程，负责协调、主控。（只有一个）</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件的时候才创建。</li><li>GPU进程：最多一个，用于3D绘制。</li><li>浏览器渲染进程（内核）：控制页面渲染，脚本执行，事件处理等。</li></ul><p>在Chrome中，打开一个标签页<code>tab</code>会新建一个渲染进程，相较于线程<code>tab</code>，有：</p><ul><li>一个tab崩溃，不会导致其他tab。</li><li>进程之间不共享资源，能够防止恶意修改或者获取非授权数据等安全行为。</li></ul><h2 id="内核" tabindex="-1">内核 <a class="header-anchor" href="#内核" aria-label="Permalink to &quot;内核&quot;">​</a></h2><p>浏览器内核是多线程，一般有以下常驻线程：</p><ul><li>GUI 渲染线程：解析页面内容和将其渲染至浏览器界面。</li><li>JavaScript引擎线程：单线程的（多线程要引入锁，带来更大的复杂度）。</li><li>定时触发器线程：setInterval与setTimeout所在的线程。</li><li>事件触发线程：将需要处理的事件添加到任务队列中，等待JS引擎的处理。</li><li>异步http请求线程：当请求的状态变更时，如果设置有回调函数，异步线程会产生状态变更事件。</li></ul><p>注意几点：</p><ul><li>由于JS引擎与GUI引擎都可操作DOM，同时运行可能引起数据不一致问题，因此两者被设计为<strong>互斥的</strong>（某一时刻只有其中一个线程在跑）。</li><li>浏览器定时计数器不是由JavaScript引擎负责的，因为JS线程处于阻塞状态时会影响记计时的准确。</li></ul><h3 id="主要内核比较" tabindex="-1">主要内核比较 <a class="header-anchor" href="#主要内核比较" aria-label="Permalink to &quot;主要内核比较&quot;">​</a></h3><ul><li>Trident：IE 浏览器内核。与 W3C 标准脱节，有大量 Bug 等 安全问题没有解决。</li><li>Gecko：Firefox 内核。功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但要消耗很多的资源，比如内存。</li><li>Presto：Opera 曾经采用的内核。浏览网页速度很快，为此牺牲了一部分网页兼容性。</li><li>Webkit：Safari内核。网页浏览速度较快，对网页代码的兼容性较低。</li><li>Blink：Chrome 浏览器内核，Webkit 的一个分支。</li></ul><h2 id="worker" tabindex="-1">Worker <a class="header-anchor" href="#worker" aria-label="Permalink to &quot;Worker&quot;">​</a></h2><p>因GUI线程与JS线程的互斥，在JS处理大量数据的时候，有可能导致页面GUI线程的<strong>假死</strong>。在这背景下，为了让页面有更好的体验，W3C在HTML5的规范中提出了Web Worker的概念，允许浏览器通过<mark>后台线程</mark>来执行复杂的事物或者逻辑。</p><p>可以通过下面方式在主线程中建立一个后台线程。当然，主线程与后台线程可以进行通信。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;workers.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="shareworkder" tabindex="-1">shareWorkder <a class="header-anchor" href="#shareworkder" aria-label="Permalink to &quot;shareWorkder&quot;">​</a></h3><p>在页面存在的生命周期内创建一个唯一的线程，并且开启的多个页面会共享该线程。当所有的页面都关闭之后该线程才被销毁。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 相同名字的shareWorkder共享同一线程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> worker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SharedWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;sharedworkers.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;myName&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>参考： <a href="https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5" target="_blank" rel="noreferrer">《JavaScript 的多线程，Worker 和 SharedWorker》</a></p><h2 id="tab通信" tabindex="-1">Tab通信 <a class="header-anchor" href="#tab通信" aria-label="Permalink to &quot;Tab通信&quot;">​</a></h2><p>浏览器的每一个tab标签都是一个独立的线程或进程。两者之间的通信可以通过引入<strong>存储中介</strong>来实现。</p><ul><li>服务器：通过[[docs/web/web#服务端推送 | 服务端推送]]技术，如websocket，标签页可以向服务器发送数据，然后服务器向其他标签页推送转发。</li><li>共享线程：通过ShareWorker可以使多个tab共享一个线程。</li><li>本地存储：localStorge 被添加、修改或删除时，会触发storage 事件，通过监听 storage 事件，可以进行页面通信。</li></ul><h1 id="解析与渲染" tabindex="-1">解析与渲染 <a class="header-anchor" href="#解析与渲染" aria-label="Permalink to &quot;解析与渲染&quot;">​</a></h1><p>大致过程为：<code>构建DOM -&gt; 构建CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制</code>。</p><p><img src="`+o+'" alt="image"></p><p><strong>构建DOM树</strong> DOM 树是DOM 元素及属性节点组成。浏览器通过<strong>深度优先遍历</strong>文档构建一棵 DOM 树。</p><p><img src="'+n+'" alt="image"></p><p><strong>构建CSSOM树</strong> 仅根据CSS构建，浏览器在 CSS 树生成之前不会进行渲染。</p><p><strong>构建渲染树</strong> 渲染树的节点被称为渲染对象。渲染树只会包括需要显示的节点和及其样式信息。因此，渲染树与DOM树并不一一对应。</p><p><img src="'+r+'" alt="image"></p><p><strong>布局与绘制</strong> 根据渲染树来进行布局，主要弄清楚各个节点在页面中的确切位置和大小。遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上。</p><blockquote><p>整个过程是逐步完成的。为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容。</p></blockquote><p>DOM加载完后将触发<code>DOMContentLoaded</code> 事件；页面渲染完毕将触发<code>onload</code> 事件。</p><h2 id="资源加载" tabindex="-1">资源加载 <a class="header-anchor" href="#资源加载" aria-label="Permalink to &quot;资源加载&quot;">​</a></h2><p>浏览器自上而下解析文档，当遇到<strong>外部资源</strong>时，有可能阻塞页面的解析或渲染过程。是否阻塞取决于各类资源的执行在页面绘制过程中<mark>是否会有冲突</mark>。</p><ul><li><p>资源的<mark>加载过程</mark>显然是独立的且不相干的，因此不必阻塞其他过程，虽然有些浏览器会。但浏览器会<mark>限制并行请求数量</mark>。</p></li><li><p>图片显示不阻塞其他过程，但可能使<mark>页面回流</mark>。</p></li><li><p>JS引擎与GUI引擎是<mark>互斥的</mark>，因此JS执行与页面解析渲染过程不能同时进行。JS默认阻塞后面页面的解析（此时JS可操作前面已解析过的DOM节点）。</p></li><li><p>DOM树与CSSOM树独立构建。因此CSS不阻塞DOM树解析，当阻塞渲染树构建。</p></li><li><p>JS可能会基于前面的节点的样式进行操作，因此CSS解析会阻塞后面的JS执行。</p></li></ul><h3 id="js加载" tabindex="-1">JS加载 <a class="header-anchor" href="#js加载" aria-label="Permalink to &quot;JS加载&quot;">​</a></h3><p>默认情况下，浏览器同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来。 可以通过加入<code>async</code>或<code>defer</code>属性改变加载JS行为。</p><p><strong>async</strong>：异步加载JS完立即执行， <strong>defer</strong>: 延迟加载，解析文档完执行。</p><blockquote><p>在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。</p></blockquote><p><img src="'+h+`" alt="image"></p><h3 id="预加载与懒加载" tabindex="-1">预加载与懒加载 <a class="header-anchor" href="#预加载与懒加载" aria-label="Permalink to &quot;预加载与懒加载&quot;">​</a></h3><p><strong>懒加载</strong>：页面中的资源（通常是图片）延迟加载，可以减少资源并行请求数量，优化用户体验。通常在<mark>电商项目</mark>中使用。</p><p>实现思路很简单，当某种行为，如滚动，点击发生时，通过JS加载资源。</p><p>以图片为例，可以这样实现：将资源<code>url</code>放在另一个属性，如<code>data-src</code>。当图片将出现在视野中时，利用JS将<code>data-src</code>的值赋给<code>src</code>，此时浏览器加载该资源。</p><p><strong>预加载</strong>：在资源尚未出现在视野，先加载，供后面直接使用。可<mark>减少白屏</mark>出现的时长。</p><p>实现的方式有：</p><ul><li>利用<code>link</code>标签的<code>preload</code>或<code>prefetch</code>。</li><li>利用<code>display:none</code>。</li><li>利用<code>Ajax</code>将资源请求并存储在变量中，再通过<code>JS</code>调用资源。</li></ul><p><strong>preload &amp; prefetch</strong></p><table tabindex="0"><thead><tr><th>/</th><th>preload</th><th>prefetch</th></tr></thead><tbody><tr><td>加载时机</td><td>立即加载，但不阻塞onload事件</td><td>浏览器闲置时加载</td></tr><tr><td>适用场景</td><td><mark>当前页面</mark>接下来要使用的资源</td><td><mark>接下来的页面</mark>的资源</td></tr><tr><td>浏览器支持</td><td>一般</td><td>较高</td></tr></tbody></table><h2 id="回流与重绘" tabindex="-1">回流与重绘 <a class="header-anchor" href="#回流与重绘" aria-label="Permalink to &quot;回流与重绘&quot;">​</a></h2><p><strong>重绘</strong>：当渲染树的一些元素需要更新属性，但这些属性不会影响布局时。 <strong>回流</strong>：当渲染树的一些元素的规模尺寸、布局、隐藏等改变而需要重新构建。</p><ul><li>计算 offsetWidth 和 offsetHeight 属性。</li><li>设置 style 属性的值。</li></ul><p><mark>回流必定会发生重绘，重绘不一定会引发回流。</mark></p><p>减少回流：</p><ul><li>使用 transform 替代 top。</li><li>使用 visibility 替换 display: none。</li><li>不要使用 table 布局，一个小改动可能会造成整个 table 的重新布局。</li><li>将动画应用到<code>absolute</code>或<code>fixed</code>的元素上。</li><li>CSS 选择符从右往左匹配查找，避免节点层级过多。</li><li>避免多次修改style，用class代替。</li><li>将频繁重绘或者回流的节点设置为图层。</li></ul><h2 id="渲染异常" tabindex="-1">渲染异常 <a class="header-anchor" href="#渲染异常" aria-label="Permalink to &quot;渲染异常&quot;">​</a></h2><p><strong>FOUC</strong>：无样式内容闪烁。有些浏览器渲染机制（比如firefox），在CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。</p><p><strong>白屏</strong>：有些浏览器渲染机制（chrome），先构建DOM树和CSSOM树，构建完成后再进行渲染。如果CSSOM树构建较慢，会导致白屏。</p><h2 id="js操作dom" tabindex="-1">JS操作DOM <a class="header-anchor" href="#js操作dom" aria-label="Permalink to &quot;JS操作DOM&quot;">​</a></h2><p>操作DOM，需要渲染引擎与JS 引擎两个进程之间进行通信，这会带来一些性能上的损耗。并且，操作 DOM 可能还会带来重绘回流的情况。</p><h1 id="数据存储" tabindex="-1">数据存储 <a class="header-anchor" href="#数据存储" aria-label="Permalink to &quot;数据存储&quot;">​</a></h1><h2 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;Cookie&quot;">​</a></h2><p>服务器端用于记录用户信息的一种方式，由服务器设置，在客户端存储。客户端发起<strong>同源请求</strong>时，会携带该信息发送给服务器端。</p><p>最多存储 4 k 数据，生存时间由 expires 属性指定。</p><h3 id="用途" tabindex="-1">用途 <a class="header-anchor" href="#用途" aria-label="Permalink to &quot;用途&quot;">​</a></h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="创建过程" tabindex="-1">创建过程 <a class="header-anchor" href="#创建过程" aria-label="Permalink to &quot;创建过程&quot;">​</a></h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HTTP/1.0 200 OK</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content-type: text/html</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set-Cookie: yummy_cookie=choco</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set-Cookie: tasty_cookie=strawberry</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[page content]</span></span></code></pre></div><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GET /sample_page.html HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Host: www.example.org</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span></span></code></pre></div><h3 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h3><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span></span></code></pre></div><h3 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h3><p>Domain 标识指定了<mark>哪些主机可以接受 Cookie</mark>。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p><p>Path 标识指定了主机下的<mark>哪些路径可以接受</mark> Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul><h3 id="访问" tabindex="-1">访问 <a class="header-anchor" href="#访问" aria-label="Permalink to &quot;访问&quot;">​</a></h3><p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.cookie = &quot;yummy_cookie=choco&quot;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.cookie = &quot;tasty_cookie=strawberry&quot;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.log(document.cookie);</span></span></code></pre></div><p>标记为 <strong>HttpOnly</strong> 的 Cookie <mark>不能被 JavaScript 脚本调用</mark>。这在一定程度上可以避免 [[attack-tech#一、跨站脚本攻击 | XSS]] 攻击。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span></span></code></pre></div><p>标记为 <strong>Secure</strong> 的 Cookie <mark>只能通过HTTPS 协议</mark>发送给服务端。</p><blockquote><p>但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p></blockquote><p>可以直接设置<strong>浏览器禁用cookie</strong>。</p><h2 id="storage" tabindex="-1">Storage <a class="header-anchor" href="#storage" aria-label="Permalink to &quot;Storage&quot;">​</a></h2><p>主要是sessionStorage 和 localStorage。，两者都属于HTML5 WebStorage，目的在于客户端存储，不参与与服务端通信。</p><p>一般大小为5M。</p><ul><li>sessionStorage在当前会话中有效（同源同窗口），关闭标签页或浏览器失效。</li><li>localStorage在同源页面都有效，且更加持久有效，除非手动在浏览器中清除。</li></ul><h2 id="indexdb" tabindex="-1">indexDB <a class="header-anchor" href="#indexdb" aria-label="Permalink to &quot;indexDB&quot;">​</a></h2><p>浏览器提供的本地数据库，可以存储大量的数据。</p><h2 id="缓存机制" tabindex="-1">缓存机制 <a class="header-anchor" href="#缓存机制" aria-label="Permalink to &quot;缓存机制&quot;">​</a></h2><p>在一段时间内保留已接收到的 web 资源的一个副本，有需要时可直接使用该副本，而不需向服务器请求。</p><p>web 资源的缓存策略一般由服务器来指定，可以分为两种——缓存策略和协商缓存策略。</p><h3 id="强缓存策略" tabindex="-1">强缓存策略 <a class="header-anchor" href="#强缓存策略" aria-label="Permalink to &quot;强缓存策略&quot;">​</a></h3><p>如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p><p>服务器可通过http 头信息中的 <code>Expires</code>和<code>Cache-Control</code> 属性指定。</p><p><code>Expires</code>：服务器的绝对时间表示，可能与客户端的不一致。 <code>Cache-Control</code>：<code>Expires</code>的改进版本，可以使用相对时间。也可以设置某些关键词：</p><ul><li>private：只能被客户端缓存，不能被代理服务器缓存。</li><li>no-store：不能被缓存。</li><li>no-cache：强制确认缓存，需要先向源服务器验证缓存资源的有效性（<strong>协商缓存</strong>）。</li><li>max-age：指定缓存资源在缓存服务器中保存的时间。</li></ul><blockquote><p>Cache-Control 的优先级要高于 Expires 。</p></blockquote><h3 id="协商缓存策略" tabindex="-1">协商缓存策略 <a class="header-anchor" href="#协商缓存策略" aria-label="Permalink to &quot;协商缓存策略&quot;">​</a></h3><p>会向服务器询问资源<mark>是否有修改</mark>，如果没修改，服务器返回<strong>304 Not Modified</strong>。</p><p>通过http <strong>响应报文</strong>中的头信息的 <code>Etag</code> 和 <code>Last-Modified</code> 属性设置。</p><p><code>Last-Modified</code>：指出资源最后一次修改时间，精确到秒级。浏览器询问时带上该参数值，与服务器比较。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">请求报文：If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span></span></code></pre></div><p><code>Etag</code>：改进版本。资源的唯一标识符。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">请求报文：If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</span></span></code></pre></div><blockquote><p>Etag 的优先级更高。 考虑负载平衡时，服务器上 Etag 的值都不一样，不应该使用Etag 属性。</p></blockquote><blockquote><p>在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的，先用强缓存策略判断，后用协商缓存策略。</p></blockquote><h1 id="bom" tabindex="-1">BOM <a class="header-anchor" href="#bom" aria-label="Permalink to &quot;BOM&quot;">​</a></h1><p>浏览器对象模型，定义了与浏览器进行交互的方法和接口。</p><h2 id="window" tabindex="-1">window <a class="header-anchor" href="#window" aria-label="Permalink to &quot;window&quot;">​</a></h2><p>BOM的核心对象是window，表示浏览器的一个实例。<mark>在浏览器中</mark>，window对象有双重角色：</p><ul><li>JS访问浏览器窗口的一个接口。</li><li>ECMAScript规定的Global对象。</li></ul><p>window对象包含属性：document、location、navigator、screen、history、frames.</p><h2 id="history" tabindex="-1">history <a class="header-anchor" href="#history" aria-label="Permalink to &quot;history&quot;">​</a></h2><h3 id="地址栏" tabindex="-1">地址栏 <a class="header-anchor" href="#地址栏" aria-label="Permalink to &quot;地址栏&quot;">​</a></h3><p>一些api可以同时修改浏览器的地址栏及历史记录。 <code>pushState()</code>：往浏览器的历史记录中添加一条新记录。 <code>replaceState()</code>：用当前的记录替换掉原来的记录。 <code>window.onpopstate</code>：监听浏览器前进、后退事件。</p><p>用途：结合<code>Ajax</code>，可以实现浏览器无刷新前进后退。</p><blockquote><p>仅在同域名下有效。</p></blockquote><h1 id="dom" tabindex="-1">DOM <a class="header-anchor" href="#dom" aria-label="Permalink to &quot;DOM&quot;">​</a></h1><p>文档对象模型，定义了与HTML文档交互的方法和接口。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p><p>DOM的节点分为三类：元素节点、文本节点和属性节点</p><h2 id="document" tabindex="-1">document <a class="header-anchor" href="#document" aria-label="Permalink to &quot;document&quot;">​</a></h2><p>DOM的核心对象是document，表示页面文档的一个实例。同时，也是window对象的一个属性。</p><h2 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h2><p>文档或浏览器窗口中发生的一些特定的交互瞬间。JS与HTML之间的交互是通过事件实现的。</p><h3 id="事件模型" tabindex="-1">事件模型 <a class="header-anchor" href="#事件模型" aria-label="Permalink to &quot;事件模型&quot;">​</a></h3><p>定义事件发生时的处理流程。有三种事件模型：</p><p><strong>DOM0 级模型</strong>：事件不会传播，没有事件流的概念。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> btn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.btn&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.onclick </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fun;</span></span></code></pre></div><p><strong>IE 事件模型</strong>：有两个过程。<mark>默认情况</mark>。</p><ul><li>事件处理阶段：事件到达目标元素，触发目标元素的监听函数。</li><li>事件冒泡阶段：事件从目标元素冒泡到document，触发经过的节点的相应事件的监听函数。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">attachEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(‘onclick’, showMessage);</span></span></code></pre></div><p><strong>DOM2 级事件模型</strong>：包含三个过程。事件捕获阶段、事件处理阶段、事件冒泡阶段。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第三个参数指定事件是否在捕获阶段执行。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">btn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(‘click’, showMessage, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="事件对象" tabindex="-1">事件对象 <a class="header-anchor" href="#事件对象" aria-label="Permalink to &quot;事件对象&quot;">​</a></h3><p>当一个事件被触发时，会创建一个事件对象<code>Event</code>。 这个对象包含与该事件相关的属性或者方法，作为第一个参数传递给监听函数。</p><p>事件对象常用属性:</p><ul><li>type：取事件类型</li><li>target：事件目标</li><li>stopPropagation()：阻止事件冒泡</li><li>preventDefault()：阻止事件默认行为</li></ul><h3 id="事件委托" tabindex="-1">事件委托 <a class="header-anchor" href="#事件委托" aria-label="Permalink to &quot;事件委托&quot;">​</a></h3><p>利用事件冒泡的机制，通过在父节点绑定监听函数，从而监听多个子节点的事件。 比起每个子节点都绑定监听函数，这样子的好处：</p><ul><li>减少内存上的消耗。</li><li>实现事件的动态绑定。</li></ul><h2 id="tricks" tabindex="-1">Tricks <a class="header-anchor" href="#tricks" aria-label="Permalink to &quot;Tricks&quot;">​</a></h2><ol><li>innerHTML 与 outerHTML：</li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HTML 元素：&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;content&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">br</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">innerHTML：content&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">br</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">outerHTML：&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;content&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">br</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">innerText：content;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">outerText：content;</span></span></code></pre></div><ol start="2"><li>mouseover 和 mouseenter ： 当鼠标移动到元素上时就会这两个事件，但mouseenter 不会冒泡。</li></ol><p>由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。</p><h1 id="相关技术" tabindex="-1">相关技术 <a class="header-anchor" href="#相关技术" aria-label="Permalink to &quot;相关技术&quot;">​</a></h1><h2 id="二维码登录" tabindex="-1">二维码登录 <a class="header-anchor" href="#二维码登录" aria-label="Permalink to &quot;二维码登录&quot;">​</a></h2><ol><li>浏览器与server端建立一个长连接，后展示二维码。</li><li>扫描二维码时手机向服务器发起一个认证。</li><li>认证成功后服务器向浏览器授权。</li></ol><h2 id="base64" tabindex="-1">base64 <a class="header-anchor" href="#base64" aria-label="Permalink to &quot;base64&quot;">​</a></h2><p>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串。在页面上显示的时候，可以用该字符串来代替图片的url属性。</p><p>优点：减少一个图片的HTTP请求。</p><p>缺点：</p><ul><li>文件大小变大。</li><li>无法直接缓存图片，只能缓存整个包含base64的文件。</li><li>兼容性的问题，ie8以前的浏览器不支持。</li></ul><blockquote><p>一般一些网站的小图标可以使用base64图片来引入。</p></blockquote>`,168)])])}const y=i(p,[["render",d]]);export{m as __pageData,y as default};
