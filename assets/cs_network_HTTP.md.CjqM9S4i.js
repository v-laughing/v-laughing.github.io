import{_ as e,c as a,o as r,a4 as l}from"./chunks/framework.DdddRsJj.js";const n="/assets/8441b2c4-dca7-4d6b-8efb-f22efccaf331.Cjn4-n5C.png",i="/assets/HTTP_RequestMessageExample.BREoQDvq.png",s="/assets/HTTP_ResponseMessageExample.BsG5zpbB.png",o="/assets/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.BIZX7tyV.jpg",h="/assets/HTTP1_x_Connections.CAa5e-Kp.png",d="/assets/a314bb79-5b18-4e63-a976-3448bffa6f1b.BGt7RmYx.png",p="/assets/2d09a847-b854-439c-9198-b29c65810944.CvGAp3sV.png",c="/assets/ssl-offloading.CK7gdRpU.jpg",g="/assets/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.DvI2Cvct.png",u="/assets/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.CMo_z7q0.png",b="/assets/How-HTTPS-Works.BRrxwfLQ.png",m="/assets/2017-06-11-ca.DsTFKv2D.png",f="/assets/86e6a91d-a285-447a-9345-c5484b8d0c47.D8-6ielL.png",x="/assets/af198da1-2480-4043-b07f-a3b91a88b815.BKNaxKKP.png",T="/assets/e3f1657c-80fc-4dfa-9643-bf51abd201c6.C_0l4Zg_.png",k="/assets/u4E0B_u8F7D.DBicK5am.png",C=JSON.parse('{"title":"一 、基础概念","description":"","frontmatter":{},"headers":[],"relativePath":"cs/network/HTTP.md","filePath":"cs/network/HTTP.md"}'),y={name:"cs/network/HTTP.md"};function P(q,t,E,_,H,S){return r(),a("div",null,[...t[0]||(t[0]=[l('<nav class="table-of-contents"><ul><li><a href="#uri">URI</a></li><li><a href="#请求和响应报文">请求和响应报文</a><ul><li><a href="#_1-请求报文">1. 请求报文</a></li><li><a href="#_2-响应报文">2. 响应报文</a></li></ul></li><li><a href="#安全性">安全性</a></li><li><a href="#幂等性">幂等性</a></li><li><a href="#缓存性">缓存性</a></li><li><a href="#get-post">GET &amp; POST</a><ul><li><a href="#参数">参数</a></li><li><a href="#xmlhttprequest">XMLHttpRequest</a></li></ul></li><li><a href="#_1xx-信息">1XX 信息</a></li><li><a href="#_2xx-成功">2XX 成功</a></li><li><a href="#_3xx-重定向">3XX 重定向</a></li><li><a href="#_4xx-客户端错误">4XX 客户端错误</a></li><li><a href="#_5xx-服务器错误">5XX 服务器错误</a></li><li><a href="#通用首部字段">通用首部字段</a></li><li><a href="#请求首部字段">请求首部字段</a></li><li><a href="#响应首部字段">响应首部字段</a></li><li><a href="#实体首部字段">实体首部字段</a></li><li><a href="#连接管理">连接管理</a><ul><li><a href="#短连接与长连接">短连接与长连接</a></li><li><a href="#流水线">流水线</a></li></ul></li><li><a href="#内容协商">内容协商</a><ul><li><a href="#_1-类型">1. 类型</a></li><li><a href="#_2-vary">2. Vary</a></li></ul></li><li><a href="#内容编码">内容编码</a></li><li><a href="#范围请求">范围请求</a><ul><li><a href="#_1-range">1. Range</a></li><li><a href="#_2-accept-ranges">2. Accept-Ranges</a></li><li><a href="#_3-响应状态码">3. 响应状态码</a></li></ul></li><li><a href="#分块传输编码">分块传输编码</a></li><li><a href="#多部分对象集合">多部分对象集合</a></li><li><a href="#虚拟主机">虚拟主机</a></li><li><a href="#通信数据转发">通信数据转发</a><ul><li><a href="#_1-代理">1. 代理</a></li><li><a href="#_2-网关">2. 网关</a></li><li><a href="#_3-隧道">3. 隧道</a></li></ul></li><li><a href="#加密">加密</a><ul><li><a href="#对称密钥加密">对称密钥加密</a></li><li><a href="#非对称密钥加密">非对称密钥加密</a></li><li><a href="#_3-https-采用的加密方式">3. HTTPS 采用的加密方式</a></li></ul></li><li><a href="#认证">认证</a></li><li><a href="#完整性保护">完整性保护</a></li><li><a href="#https-的缺点">HTTPS 的缺点</a></li><li><a href="#http-1-x-缺陷">HTTP/1.x 缺陷</a></li><li><a href="#二进制分帧层">二进制分帧层</a></li><li><a href="#服务端推送">服务端推送</a></li><li><a href="#首部压缩">首部压缩</a></li></ul></nav><h1 id="一-、基础概念" tabindex="-1">一 、基础概念 <a class="header-anchor" href="#一-、基础概念" aria-label="Permalink to &quot;一 、基础概念&quot;">​</a></h1><p><strong>超文本传输协议（HTTP）</strong> 是一个用于<mark>传输超媒体文档</mark>（例如 HTML）的<mark>应用层协议</mark>。HTTP 遵循经典的客户端-服务端模型。是<strong>无状态协议</strong>，这意味着服务器不会在两个请求之间保留任何数据（状态）。<mark>一般基于TCP/IP可靠协议</mark>。</p><h2 id="uri" tabindex="-1">URI <a class="header-anchor" href="#uri" aria-label="Permalink to &quot;URI&quot;">​</a></h2><p><strong>URI</strong>：统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义。</p><p><strong>URL</strong>： 指的是统一资源定位符，可以理解为使用地址来标识资源。</p><p><strong>URN</strong>：统一资源名称，可以理解为使用名称来标识资源。</p><p><img src="'+n+'" alt="avatar | 500"><br></p><h2 id="请求和响应报文" tabindex="-1">请求和响应报文 <a class="header-anchor" href="#请求和响应报文" aria-label="Permalink to &quot;请求和响应报文&quot;">​</a></h2><h3 id="_1-请求报文" tabindex="-1">1. 请求报文 <a class="header-anchor" href="#_1-请求报文" aria-label="Permalink to &quot;1. 请求报文&quot;">​</a></h3><p><img src="'+i+'" alt="avatar"><br></p><h3 id="_2-响应报文" tabindex="-1">2. 响应报文 <a class="header-anchor" href="#_2-响应报文" aria-label="Permalink to &quot;2. 响应报文&quot;">​</a></h3><p><img src="'+s+'" alt="avatar"><br></p><h1 id="二、http-方法" tabindex="-1">二、HTTP 方法 <a class="header-anchor" href="#二、http-方法" aria-label="Permalink to &quot;二、HTTP 方法&quot;">​</a></h1><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p><p><strong>GET</strong>：获取资源。</p><p><strong>HEAD</strong>：获取报文首部，用于确认 URL 的有效性以及资源更新的日期时间等。</p><p><strong>POST</strong>：主要用于传输数据。</p><p><strong>PUT</strong>：更新资源，幂等性。</p><blockquote><p>不带验证机制，存在安全性问题，<mark>一般不使用该方法</mark>。</p></blockquote><p><strong>PATCH</strong>：对资源进行部分修改。</p><p><strong>DELETE</strong>：删除资源。</p><p><strong>OPTIONS</strong>：查询指定的 URL 能够支持的方法。</p><blockquote><p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p></blockquote><p><strong>CONNECT</strong>：要求在与<strong>代理服务器</strong>通信时建立隧道。</p><blockquote><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p></blockquote><p><img src="'+o+`" alt="avatar"><br></p><p><strong>TRACE</strong>：服务器会将通信路径返回给客户端。</p><blockquote><p>通常不会使用 TRACE，并且它<mark>容易受到 XST 攻击</mark>（Cross-Site Tracing，跨站追踪）。</p></blockquote><h2 id="安全性" tabindex="-1">安全性 <a class="header-anchor" href="#安全性" aria-label="Permalink to &quot;安全性&quot;">​</a></h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>安全的方法有：GET、HEAD、OPTIONS。</p><p>不安全的方法有 POST、PUT、DELETE。</p><h2 id="幂等性" tabindex="-1">幂等性 <a class="header-anchor" href="#幂等性" aria-label="Permalink to &quot;幂等性&quot;">​</a></h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 <mark>POST 方法不是</mark>。</p><h2 id="缓存性" tabindex="-1">缓存性 <a class="header-anchor" href="#缓存性" aria-label="Permalink to &quot;缓存性&quot;">​</a></h2><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h2 id="get-post" tabindex="-1">GET &amp; POST <a class="header-anchor" href="#get-post" aria-label="Permalink to &quot;GET &amp; POST&quot;">​</a></h2><h3 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h3><p>GET 的参数以查询字符串出现在 URL 中。POST 的参数存储在实体主体中。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>POST /test/demo_form.asp HTTP/1.1</span></span>
<span class="line"><span>Host: w3schools.com</span></span>
<span class="line"><span>name1=value1&amp;name2=value2</span></span></code></pre></div><h3 id="xmlhttprequest" tabindex="-1">XMLHttpRequest <a class="header-anchor" href="#xmlhttprequest" aria-label="Permalink to &quot;XMLHttpRequest&quot;">​</a></h3><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会<mark>先发送 Header 再发送 Data</mark>。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h1 id="三、http-状态码" tabindex="-1">三、HTTP 状态码 <a class="header-anchor" href="#三、http-状态码" aria-label="Permalink to &quot;三、HTTP 状态码&quot;">​</a></h1><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table tabindex="0"><thead><tr><th style="text-align:center;">状态码</th><th style="text-align:center;">类别</th><th style="text-align:center;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">1XX</td><td style="text-align:center;">Informational（信息性状态码）</td><td style="text-align:center;">接收的请求正在处理</td></tr><tr><td style="text-align:center;">2XX</td><td style="text-align:center;">Success（成功状态码）</td><td style="text-align:center;">请求正常处理完毕</td></tr><tr><td style="text-align:center;">3XX</td><td style="text-align:center;">Redirection（重定向状态码）</td><td style="text-align:center;">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center;">4XX</td><td style="text-align:center;">Client Error（客户端错误状态码）</td><td style="text-align:center;">服务器无法处理请求</td></tr><tr><td style="text-align:center;">5XX</td><td style="text-align:center;">Server Error（服务器错误状态码）</td><td style="text-align:center;">服务器处理请求出错</td></tr></tbody></table><h2 id="_1xx-信息" tabindex="-1">1XX 信息 <a class="header-anchor" href="#_1xx-信息" aria-label="Permalink to &quot;1XX 信息&quot;">​</a></h2><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h2 id="_2xx-成功" tabindex="-1">2XX 成功 <a class="header-anchor" href="#_2xx-成功" aria-label="Permalink to &quot;2XX 成功&quot;">​</a></h2><ul><li><p><strong>200 OK</strong></p></li><li><p><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文<mark>不包含实体的主体部分</mark>。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p></li><li><p><strong>206 Partial Content</strong> ：表示客户端进行了<strong>范围请求</strong>，响应报文包含由 Content-Range 指定范围的实体内容。</p></li></ul><h2 id="_3xx-重定向" tabindex="-1">3XX 重定向 <a class="header-anchor" href="#_3xx-重定向" aria-label="Permalink to &quot;3XX 重定向&quot;">​</a></h2><ul><li><p><strong>301 Moved Permanently</strong> ：永久性重定向，请求的资源已经被移动到了由 Location 头部指定的url上，搜索引擎会根据该响应修正。</p></li><li><p><strong>302 Found</strong> ：临时性重定向，搜索引擎不会对该资源的链接进行更新。</p></li><li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p></li></ul><blockquote><p>虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p></blockquote><ul><li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p></li><li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p></li></ul><h2 id="_4xx-客户端错误" tabindex="-1">4XX 客户端错误 <a class="header-anchor" href="#_4xx-客户端错误" aria-label="Permalink to &quot;4XX 客户端错误&quot;">​</a></h2><ul><li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p></li><li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。能再继续进行验证。</p></li><li><p><strong>403 Forbidden</strong> ：请求被拒绝，不能再继续进行验证。</p></li><li><p><strong>404 Not Found</strong> ：无法找到所请求的资源。</p></li></ul><h2 id="_5xx-服务器错误" tabindex="-1">5XX 服务器错误 <a class="header-anchor" href="#_5xx-服务器错误" aria-label="Permalink to &quot;5XX 服务器错误&quot;">​</a></h2><ul><li><p><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</p></li><li><p><strong>503 Service Unavailable</strong> ：服务器暂时处于<mark>超负载</mark>或正在进行停机维护，现在无法处理请求。</p></li><li><p><strong>504（Gateway timeout）</strong>：<mark>网关超时</mark>，没有及时从上游服务器收到请求。</p></li></ul><h1 id="四、http-首部" tabindex="-1">四、HTTP 首部 <a class="header-anchor" href="#四、http-首部" aria-label="Permalink to &quot;四、HTTP 首部&quot;">​</a></h1><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h2 id="通用首部字段" tabindex="-1">通用首部字段 <a class="header-anchor" href="#通用首部字段" aria-label="Permalink to &quot;通用首部字段&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">Cache-Control</td><td style="text-align:center;">控制缓存的行为</td></tr><tr><td style="text-align:center;">Connection</td><td style="text-align:center;">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td style="text-align:center;">Date</td><td style="text-align:center;">创建报文的日期时间</td></tr><tr><td style="text-align:center;">Pragma</td><td style="text-align:center;">报文指令</td></tr><tr><td style="text-align:center;">Trailer</td><td style="text-align:center;">报文末端的首部一览</td></tr><tr><td style="text-align:center;">Transfer-Encoding</td><td style="text-align:center;">指定报文主体的传输编码方式</td></tr><tr><td style="text-align:center;">Upgrade</td><td style="text-align:center;">升级为其他协议</td></tr><tr><td style="text-align:center;">Via</td><td style="text-align:center;">代理服务器的相关信息</td></tr><tr><td style="text-align:center;">Warning</td><td style="text-align:center;">错误通知</td></tr></tbody></table><h2 id="请求首部字段" tabindex="-1">请求首部字段 <a class="header-anchor" href="#请求首部字段" aria-label="Permalink to &quot;请求首部字段&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">Accept</td><td style="text-align:center;">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:center;">Accept-Charset</td><td style="text-align:center;">优先的字符集</td></tr><tr><td style="text-align:center;">Accept-Encoding</td><td style="text-align:center;">优先的内容编码</td></tr><tr><td style="text-align:center;">Accept-Language</td><td style="text-align:center;">优先的语言（自然语言）</td></tr><tr><td style="text-align:center;">Authorization</td><td style="text-align:center;">Web 认证信息</td></tr><tr><td style="text-align:center;">Expect</td><td style="text-align:center;">期待服务器的特定行为</td></tr><tr><td style="text-align:center;">From</td><td style="text-align:center;">用户的电子邮箱地址</td></tr><tr><td style="text-align:center;">Host</td><td style="text-align:center;">请求资源所在服务器</td></tr><tr><td style="text-align:center;">If-Match</td><td style="text-align:center;">比较实体标记（ETag）</td></tr><tr><td style="text-align:center;">If-Modified-Since</td><td style="text-align:center;">比较资源的更新时间</td></tr><tr><td style="text-align:center;">If-None-Match</td><td style="text-align:center;">比较实体标记（与 If-Match 相反）</td></tr><tr><td style="text-align:center;">If-Range</td><td style="text-align:center;">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td style="text-align:center;">If-Unmodified-Since</td><td style="text-align:center;">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td style="text-align:center;">Max-Forwards</td><td style="text-align:center;">最大传输逐跳数</td></tr><tr><td style="text-align:center;">Proxy-Authorization</td><td style="text-align:center;">代理服务器要求客户端的认证信息</td></tr><tr><td style="text-align:center;">Range</td><td style="text-align:center;">实体的字节范围请求</td></tr><tr><td style="text-align:center;">Referer</td><td style="text-align:center;">对请求中 URI 的原始获取方</td></tr><tr><td style="text-align:center;">TE</td><td style="text-align:center;">传输编码的优先级</td></tr><tr><td style="text-align:center;">User-Agent</td><td style="text-align:center;">HTTP 客户端程序的信息</td></tr></tbody></table><h2 id="响应首部字段" tabindex="-1">响应首部字段 <a class="header-anchor" href="#响应首部字段" aria-label="Permalink to &quot;响应首部字段&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">Accept-Ranges</td><td style="text-align:center;">是否接受字节范围请求</td></tr><tr><td style="text-align:center;">Age</td><td style="text-align:center;">推算资源创建经过时间</td></tr><tr><td style="text-align:center;">ETag</td><td style="text-align:center;">资源的匹配信息</td></tr><tr><td style="text-align:center;">Location</td><td style="text-align:center;">令客户端重定向至指定 URI</td></tr><tr><td style="text-align:center;">Proxy-Authenticate</td><td style="text-align:center;">代理服务器对客户端的认证信息</td></tr><tr><td style="text-align:center;">Retry-After</td><td style="text-align:center;">对再次发起请求的时机要求</td></tr><tr><td style="text-align:center;">Server</td><td style="text-align:center;">HTTP 服务器的安装信息</td></tr><tr><td style="text-align:center;">Vary</td><td style="text-align:center;">代理服务器缓存的管理信息</td></tr><tr><td style="text-align:center;">WWW-Authenticate</td><td style="text-align:center;">服务器对客户端的认证信息</td></tr></tbody></table><h2 id="实体首部字段" tabindex="-1">实体首部字段 <a class="header-anchor" href="#实体首部字段" aria-label="Permalink to &quot;实体首部字段&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">首部字段名</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">Allow</td><td style="text-align:center;">资源可支持的 HTTP 方法</td></tr><tr><td style="text-align:center;">Content-Encoding</td><td style="text-align:center;">实体主体适用的编码方式</td></tr><tr><td style="text-align:center;">Content-Language</td><td style="text-align:center;">实体主体的自然语言</td></tr><tr><td style="text-align:center;">Content-Length</td><td style="text-align:center;">实体主体的大小</td></tr><tr><td style="text-align:center;">Content-Location</td><td style="text-align:center;">替代对应资源的 URI</td></tr><tr><td style="text-align:center;">Content-MD5</td><td style="text-align:center;">实体主体的报文摘要</td></tr><tr><td style="text-align:center;">Content-Range</td><td style="text-align:center;">实体主体的位置范围</td></tr><tr><td style="text-align:center;">Content-Type</td><td style="text-align:center;">实体主体的媒体类型</td></tr><tr><td style="text-align:center;">Expires</td><td style="text-align:center;">实体主体过期的日期时间</td></tr><tr><td style="text-align:center;">Last-Modified</td><td style="text-align:center;">资源的最后修改日期时间</td></tr></tbody></table><h1 id="五、具体应用" tabindex="-1">五、具体应用 <a class="header-anchor" href="#五、具体应用" aria-label="Permalink to &quot;五、具体应用&quot;">​</a></h1><h2 id="连接管理" tabindex="-1">连接管理 <a class="header-anchor" href="#连接管理" aria-label="Permalink to &quot;连接管理&quot;">​</a></h2><p><img src="`+h+`" alt="avatar | 700"><br></p><h3 id="短连接与长连接" tabindex="-1">短连接与长连接 <a class="header-anchor" href="#短连接与长连接" aria-label="Permalink to &quot;短连接与长连接&quot;">​</a></h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。即，在一个连接上的<mark>通信复用</mark>，并且由其中一端<mark>主动关闭</mark>。区别于[[link#keep-alive|TCP长连接]]。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h3 id="流水线" tabindex="-1">流水线 <a class="header-anchor" href="#流水线" aria-label="Permalink to &quot;流水线&quot;">​</a></h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h2 id="内容协商" tabindex="-1">内容协商 <a class="header-anchor" href="#内容协商" aria-label="Permalink to &quot;内容协商&quot;">​</a></h2><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p><h3 id="_1-类型" tabindex="-1">1. 类型 <a class="header-anchor" href="#_1-类型" aria-label="Permalink to &quot;1. 类型&quot;">​</a></h3><p><strong>1.1 服务端驱动型</strong></p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><p><strong>1.2 代理驱动型</strong></p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p><h3 id="_2-vary" tabindex="-1">2. Vary <a class="header-anchor" href="#_2-vary" aria-label="Permalink to &quot;2. Vary&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vary: Accept-Language</span></span></code></pre></div><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p><p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p><h2 id="内容编码" tabindex="-1">内容编码 <a class="header-anchor" href="#内容编码" aria-label="Permalink to &quot;内容编码&quot;">​</a></h2><p>内容编码<mark>将实体主体进行压缩</mark>，从而减少传输的数据量。</p><p>常用的内容编码有：gzip、compress、deflate、identity。</p><p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p><h2 id="范围请求" tabindex="-1">范围请求 <a class="header-anchor" href="#范围请求" aria-label="Permalink to &quot;范围请求&quot;">​</a></h2><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p><h3 id="_1-range" tabindex="-1">1. Range <a class="header-anchor" href="#_1-range" aria-label="Permalink to &quot;1. Range&quot;">​</a></h3><p>在请求报文中添加 Range 首部字段指定请求的范围。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GET /z4d4kWk.jpg HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Host: i.imgur.com</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Range: bytes=0-1023</span></span></code></pre></div><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HTTP/1.1 206 Partial Content</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content-Range: bytes 0-1023/146515</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content-Length: 1024</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(binary content)</span></span></code></pre></div><h3 id="_2-accept-ranges" tabindex="-1">2. Accept-Ranges <a class="header-anchor" href="#_2-accept-ranges" aria-label="Permalink to &quot;2. Accept-Ranges&quot;">​</a></h3><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Accept-Ranges: bytes</span></span></code></pre></div><h3 id="_3-响应状态码" tabindex="-1">3. 响应状态码 <a class="header-anchor" href="#_3-响应状态码" aria-label="Permalink to &quot;3. 响应状态码&quot;">​</a></h3><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul><h2 id="分块传输编码" tabindex="-1">分块传输编码 <a class="header-anchor" href="#分块传输编码" aria-label="Permalink to &quot;分块传输编码&quot;">​</a></h2><p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p><h2 id="多部分对象集合" tabindex="-1">多部分对象集合 <a class="header-anchor" href="#多部分对象集合" aria-label="Permalink to &quot;多部分对象集合&quot;">​</a></h2><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content-Type: multipart/form-data; boundary=AaB03x</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--AaB03x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content-Disposition: form-data; name=&quot;submit-name&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Larry</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--AaB03x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Content-Type: text/plain</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">... contents of file1.txt ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--AaB03x--</span></span></code></pre></div><h2 id="虚拟主机" tabindex="-1">虚拟主机 <a class="header-anchor" href="#虚拟主机" aria-label="Permalink to &quot;虚拟主机&quot;">​</a></h2><p>HTTP/1.1 使用虚拟主机技术，使得<mark>一台服务器拥有多个域名</mark>，并且在逻辑上可以看成多个服务器。</p><h2 id="通信数据转发" tabindex="-1">通信数据转发 <a class="header-anchor" href="#通信数据转发" aria-label="Permalink to &quot;通信数据转发&quot;">​</a></h2><h3 id="_1-代理" tabindex="-1">1. 代理 <a class="header-anchor" href="#_1-代理" aria-label="Permalink to &quot;1. 代理&quot;">​</a></h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：</p><ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul><p>代理服务器分为正向代理和反向代理两种：</p><p><strong>正向代理</strong> 代理服务器<strong>代理了客户端</strong>，去和目标服务器进行交互。用户察觉得到正向代理的存在。</p><p>用途：</p><ul><li>突破访问限制，隐藏客户端真实IP。如科学上网。</li><li>提高访问速度。通常代理服务器都设置一个较大的硬盘缓冲，缓存部分请求的响应。</li></ul><p><img src="`+d+'" alt="avatar"><br></p><p><strong>反向代理</strong> 代理服务器<strong>代理了目标服务器</strong>，去和客户端进行交互。反向代理一般位于内部网络中，用户察觉不到。</p><p>用途：</p><ul><li>提供安全保障、隐藏服务器真实IP。作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护。</li><li>负载均衡、提高访问速度。缓存及请求分发。</li></ul><p><img src="'+p+'" alt="avatar"><br></p><h3 id="_2-网关" tabindex="-1">2. 网关 <a class="header-anchor" href="#_2-网关" aria-label="Permalink to &quot;2. 网关&quot;">​</a></h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为<mark>其它协议进行通信</mark>，从而请求其它非 HTTP 服务器的服务。</p><h3 id="_3-隧道" tabindex="-1">3. 隧道 <a class="header-anchor" href="#_3-隧道" aria-label="Permalink to &quot;3. 隧道&quot;">​</a></h3><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条<mark>安全的通信线路</mark>。</p><h1 id="六、https" tabindex="-1">六、HTTPS <a class="header-anchor" href="#六、https" aria-label="Permalink to &quot;六、HTTPS&quot;">​</a></h1><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><p><img src="'+c+'" alt="avatar | 700"><br></p><h2 id="加密" tabindex="-1">加密 <a class="header-anchor" href="#加密" aria-label="Permalink to &quot;加密&quot;">​</a></h2><h3 id="对称密钥加密" tabindex="-1">对称密钥加密 <a class="header-anchor" href="#对称密钥加密" aria-label="Permalink to &quot;对称密钥加密&quot;">​</a></h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><p><img src="'+g+'" alt="avatar | 600"><br></p><h3 id="非对称密钥加密" tabindex="-1">非对称密钥加密 <a class="header-anchor" href="#非对称密钥加密" aria-label="Permalink to &quot;非对称密钥加密&quot;">​</a></h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。可以<mark>保证单个方向传输的安全性</mark>。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><p><img src="'+u+'" alt="avatar | 600"><br></p><h3 id="_3-https-采用的加密方式" tabindex="-1">3. HTTPS 采用的加密方式 <a class="header-anchor" href="#_3-https-采用的加密方式" aria-label="Permalink to &quot;3. HTTPS 采用的加密方式&quot;">​</a></h3><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS <mark>采用混合的加密机制</mark>，正是利用了上面提到的方案：</p><ul><li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li><li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li></ul><p><img src="'+b+'" alt="avatar | 600"><br></p><h2 id="认证" tabindex="-1">认证 <a class="header-anchor" href="#认证" aria-label="Permalink to &quot;认证&quot;">​</a></h2><p><strong>中间人攻击</strong></p><blockquote><p>中间人劫持到服务器发送给客户端的公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B。从而获取客户端发给服务器的内容。</p></blockquote><p>根本原因是浏览器无法确认自己收到的<mark>公钥是不是网站自己的</mark>。</p><p>通过使用<strong>证书</strong>来对通信方进行认证。证书如同<strong>身份证</strong>，可以证明“该公钥对应该网站”。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p><strong>数字签名：保障证书不被篡改</strong> 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对证书（包含服务器公钥信息）做数字签名。 服务器把证书发送给客户端。客户端拥有CA的公开密钥，对证书的数字签名进行验证，如果验证通过，就可以开始通信了。</p><p><img src="'+m+'" alt="avatar"><br></p><p><strong>证书被掉包</strong> 证书包含了服务器端的信息，由此客户端可以判断该证书是否被掉包。</p><h2 id="完整性保护" tabindex="-1">完整性保护 <a class="header-anchor" href="#完整性保护" aria-label="Permalink to &quot;完整性保护&quot;">​</a></h2><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h2 id="https-的缺点" tabindex="-1">HTTPS 的缺点 <a class="header-anchor" href="#https-的缺点" aria-label="Permalink to &quot;HTTPS 的缺点&quot;">​</a></h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h1 id="七、http-2-0" tabindex="-1">七、HTTP/2.0 <a class="header-anchor" href="#七、http-2-0" aria-label="Permalink to &quot;七、HTTP/2.0&quot;">​</a></h1><h2 id="http-1-x-缺陷" tabindex="-1">HTTP/1.x 缺陷 <a class="header-anchor" href="#http-1-x-缺陷" aria-label="Permalink to &quot;HTTP/1.x 缺陷&quot;">​</a></h2><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><h2 id="二进制分帧层" tabindex="-1">二进制分帧层 <a class="header-anchor" href="#二进制分帧层" aria-label="Permalink to &quot;二进制分帧层&quot;">​</a></h2><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><p><img src="'+f+'" alt="avatar | 400"><br></p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p><img src="'+x+'" alt="avatar | 600"><br></p><h2 id="服务端推送" tabindex="-1">服务端推送 <a class="header-anchor" href="#服务端推送" aria-label="Permalink to &quot;服务端推送&quot;">​</a></h2><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p><img src="'+T+'" alt="avatar | 800"><br></p><h2 id="首部压缩" tabindex="-1">首部压缩 <a class="header-anchor" href="#首部压缩" aria-label="Permalink to &quot;首部压缩&quot;">​</a></h2><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><p><img src="'+k+'" alt="avatar | 600"><br></p><h1 id="八、http-1-1-新特性" tabindex="-1">八、HTTP/1.1 新特性 <a class="header-anchor" href="#八、http-1-1-新特性" aria-label="Permalink to &quot;八、HTTP/1.1 新特性&quot;">​</a></h1><p>详细内容请见上文</p><ul><li>默认是长连接</li><li>支持流水线</li><li>支持同时打开多个 TCP 连接</li><li>支持虚拟主机</li><li>新增状态码 100</li><li>支持分块传输编码</li><li>新增缓存处理指令 max-age</li></ul><h1 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h1><ul><li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="noreferrer">MDN : HTTP</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noreferrer">HTTP/2 简介</a></li><li><a href="http://php.net/manual/zh/function.htmlspecialchars.php" target="_blank" rel="noreferrer">htmlspecialchars</a></li><li><a href="http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java" target="_blank" rel="noreferrer">Difference between file URI and URL in java</a></li><li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement" target="_blank" rel="noreferrer">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li><li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noreferrer">浅谈 HTTP 中 Get 与 Post 的区别</a></li><li><a href="https://www.webdancers.com/are-http-and-www-necesary/" target="_blank" rel="noreferrer">Are http:// and www really necessary?</a></li><li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noreferrer">HTTP (HyperText Transfer Protocol)</a></li><li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/" target="_blank" rel="noreferrer">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li><li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg" target="_blank" rel="noreferrer">File:HTTP persistent connection.svg</a></li><li><a href="https://en.wikipedia.org/wiki/Proxy_server" target="_blank" rel="noreferrer">Proxy server</a></li><li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html" target="_blank" rel="noreferrer">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li><li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/" target="_blank" rel="noreferrer">What is SSL Offloading?</a></li><li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html" target="_blank" rel="noreferrer">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li><li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" target="_blank" rel="noreferrer">An Introduction to Mutual SSL Authentication</a></li><li><a href="https://danielmiessler.com/study/url-uri/" target="_blank" rel="noreferrer">The Difference Between URLs and URIs</a></li><li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment" target="_blank" rel="noreferrer">Cookie 与 Session 的区别</a></li><li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="noreferrer">COOKIE 和 SESSION 有什么区别</a></li><li><a href="https://harttle.land/2015/08/10/cookie-session.html" target="_blank" rel="noreferrer">Cookie/Session 的机制与安全</a></li><li><a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noreferrer">HTTPS 证书原理</a></li><li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" target="_blank" rel="noreferrer">What is the difference between a URI, a URL and a URN?</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noreferrer">XMLHttpRequest</a></li><li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" target="_blank" rel="noreferrer">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li><li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences" target="_blank" rel="noreferrer">Symmetric vs. Asymmetric Encryption – What are differences?</a></li><li><a href="https://www.kancloud.cn/digest/web-performance-http2" target="_blank" rel="noreferrer">Web 性能优化与 HTTP/2</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noreferrer">HTTP/2 简介</a></li></ul>',199)])])}const A=e(y,[["render",P]]);export{C as __pageData,A as default};
