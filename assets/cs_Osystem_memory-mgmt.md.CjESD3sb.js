import{_ as a,c as e,o as t,a4 as s}from"./chunks/framework.CBsUJNCA.js";const p="/assets/7b281b1e-0595-402b-ae35-8c91084c33c1.DHs8io7Q.png",o="/assets/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.T0y15Bo-.png",r="/assets/eb859228-c0f2-4bce-910d-d9f76929352b.Da6oysOB.png",i="/assets/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.DFfgmumF.png",l="/assets/5f5ef0b6-98ea-497c-a007-f6c55288eab1.w5UkxiCZ.png",c="/assets/22de0538-7c6e-4365-bd3b-8ce3c5900216.sTFYeOBN.png",n="/assets/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.DzMLi1S4.png",v=JSON.parse('{"title":"虚拟内存","description":"","frontmatter":{},"headers":[],"relativePath":"cs/Osystem/memory-mgmt.md","filePath":"cs/Osystem/memory-mgmt.md"}'),h={name:"cs/Osystem/memory-mgmt.md"},d=s('<h1 id="虚拟内存" tabindex="-1">虚拟内存 <a class="header-anchor" href="#虚拟内存" aria-label="Permalink to &quot;虚拟内存&quot;">​</a></h1><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>每个程序所用的地址是虚拟内存地址，所用的内存称为地址空间，基本单位是页。程序执行时，页被映射到物理内存，如果映射失败，则到硬盘寻找。</p><p>以这样的方式，计算机可以运行比内存大的程序，因为程序不必一次性全部加载进内存。</p><p><img src="'+p+'" alt="avatar"><br></p><h1 id="分页系统地址映射" tabindex="-1">分页系统地址映射 <a class="header-anchor" href="#分页系统地址映射" aria-label="Permalink to &quot;分页系统地址映射&quot;">​</a></h1><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><p><img src="'+o+'" alt="avatar | 500"><br></p><h1 id="页面置换算法" tabindex="-1">页面置换算法 <a class="header-anchor" href="#页面置换算法" aria-label="Permalink to &quot;页面置换算法&quot;">​</a></h1><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h2 id="_1-最佳" tabindex="-1">1. 最佳 <a class="header-anchor" href="#_1-最佳" aria-label="Permalink to &quot;1. 最佳&quot;">​</a></h2><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种<mark>理论上的算法</mark>，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span></span></code></pre></div><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h2 id="_2-最近最久未使用" tabindex="-1">2. 最近最久未使用 <a class="header-anchor" href="#_2-最近最久未使用" aria-label="Permalink to &quot;2. 最近最久未使用&quot;">​</a></h2><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个<mark>页面移到链表表头</mark>。这样就能保证<mark>链表表尾</mark>的页面<mark>是最近最久未访问</mark>的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">4，7，0，7，1，0，1，2，1，2，6</span></span></code></pre></div><p><img src="'+r+'" alt="avatar"><br></p><h2 id="_3-最近未使用" tabindex="-1">3. 最近未使用 <a class="header-anchor" href="#_3-最近未使用" aria-label="Permalink to &quot;3. 最近未使用&quot;">​</a></h2><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 <mark>R 位会定时被清零</mark>。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h2 id="_4-先进先出" tabindex="-1">4. 先进先出 <a class="header-anchor" href="#_4-先进先出" aria-label="Permalink to &quot;4. 先进先出&quot;">​</a></h2><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h2 id="_5-第二次机会算法" tabindex="-1">5. 第二次机会算法 <a class="header-anchor" href="#_5-第二次机会算法" aria-label="Permalink to &quot;5. 第二次机会算法&quot;">​</a></h2><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p><img src="'+i+'" alt="avatar"><br></p><h2 id="_6-时钟" tabindex="-1">6. 时钟 <a class="header-anchor" href="#_6-时钟" aria-label="Permalink to &quot;6. 时钟&quot;">​</a></h2><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><p><img src="'+l+'" alt="avatar"><br></p><h1 id="内存分配" tabindex="-1">内存分配 <a class="header-anchor" href="#内存分配" aria-label="Permalink to &quot;内存分配&quot;">​</a></h1><h1 id="分段" tabindex="-1">分段 <a class="header-anchor" href="#分段" aria-label="Permalink to &quot;分段&quot;">​</a></h1><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><img src="'+c+'" alt="avatar"><br></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><p><img src="'+n+'" alt="avatar"><br></p><h1 id="段页式" tabindex="-1">段页式 <a class="header-anchor" href="#段页式" aria-label="Permalink to &quot;段页式&quot;">​</a></h1><p><code>程序</code>-&gt;<code>段</code>-&gt;<code>页</code> 程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h1 id="分页与分段的比较" tabindex="-1">分页与分段的比较 <a class="header-anchor" href="#分页与分段的比较" aria-label="Permalink to &quot;分页与分段的比较&quot;">​</a></h1><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p></li><li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为<mark>逻辑上独立的地址空间</mark>并且有助于共享和保护。</p></li></ul>',57),m=[d];function b(u,_,k,g,f,q){return t(),e("div",null,m)}const P=a(h,[["render",b]]);export{v as __pageData,P as default};
