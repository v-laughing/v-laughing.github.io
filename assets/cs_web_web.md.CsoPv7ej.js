import{_ as i,c as a,o as l,a4 as n}from"./chunks/framework.DdddRsJj.js";const e="/assets/http-tls.4DMAB0z7.jpg",t="/assets/nginx2flask.q25KTKVu.jpg",g=JSON.parse('{"title":"页面请求过程","description":"","frontmatter":{},"headers":[],"relativePath":"cs/web/web.md","filePath":"cs/web/web.md"}'),h={name:"cs/web/web.md"};function p(k,s,r,o,d,E){return l(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="页面请求过程" tabindex="-1">页面请求过程 <a class="header-anchor" href="#页面请求过程" aria-label="Permalink to &quot;页面请求过程&quot;">​</a></h1><h2 id="准备" tabindex="-1">准备 <a class="header-anchor" href="#准备" aria-label="Permalink to &quot;准备&quot;">​</a></h2><p>URL解析 -&gt; [[browser#缓存机制 | 检测缓存]]</p><blockquote><p><strong>URL解析</strong>：判断URL的合法性，并对URL进行字符编码等操作。以及其他额外的操作，如安全检查、访问限制。</p></blockquote><h2 id="请求" tabindex="-1">请求 <a class="header-anchor" href="#请求" aria-label="Permalink to &quot;请求&quot;">​</a></h2><p>浏览器网络请求线程 -&gt; [[../network/application#域名系统 | DNS域名解析]] -&gt; [[../network/HTTP | HTTP]]、[[../network/transport#TCP连接管理 | TCP/IP]] -&gt; 一系列报文封装过程。</p><h1 id="通信技术" tabindex="-1">通信技术 <a class="header-anchor" href="#通信技术" aria-label="Permalink to &quot;通信技术&quot;">​</a></h1><p><strong>XMLHttpRequest</strong>：能够进行客户端与服务器的通信对象。</p><h2 id="ajax" tabindex="-1">Ajax <a class="header-anchor" href="#ajax" aria-label="Permalink to &quot;Ajax&quot;">​</a></h2><p>基于XMLHttpRequest的异步通信方式。 可以直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</p><p>一般实现：设置对象的属性和监听函数后，调用 sent 即可向服务器发起请求。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getRes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xhr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> XMLHttpRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;GET&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, url, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置状态的监听函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onreadystatechange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.readyState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.response);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.statusText));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置错误监听函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.statusText));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置响应的数据类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xhr.responseType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置请求头信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setRequestHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Accept&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;application/json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 发送 http 请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xhr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>缺点：</p><ul><li>仅支持同源请求。</li><li>API难用。</li></ul><h2 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h2><h3 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h3><p>从一个源加载的脚本默认不能访问另一个源的资源。<mark>浏览器</mark>的一个<mark>安全限制</mark>，一定程度上可以阻止CSRF攻击。主要的限制有：</p><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取。</li><li>DOM 无法获得。</li><li>AJAX 请求不能发送。</li></ul><blockquote><p>同源：两个端的协议，端口或者域名都相同。</p></blockquote><h3 id="跨域技术" tabindex="-1">跨域技术 <a class="header-anchor" href="#跨域技术" aria-label="Permalink to &quot;跨域技术&quot;">​</a></h3><p>依赖技巧或api：</p><ul><li><p><strong>主域名</strong>：如果两个网页的主域名相同，浏览器允许通过设置<code>document.domain</code>共享 Cookie，访问<code>iframe</code>窗口。</p></li><li><p><strong>window.name</strong>：在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。无论是否同源。</p></li><li><p><strong>window.postMessage</strong>：跨窗口通信，不论是否同源。<code>H5的api</code></p></li></ul><p>依赖能够执行跨源请求的DOM特性的技术：</p><ul><li><strong>图片探测</strong>：基于可以跨域加载图片，通过监听其onload和onerror事件得知什么时候收到回应。</li></ul><blockquote><p>浏览器无法获得服务器信息，常用于动态显示广告。</p></blockquote><ul><li><strong>JSONP</strong>：基于浏览器可以跨域加载JS脚本的特点。可实现浏览器与服务器的双向通信。</li></ul><blockquote><p>简单适用，老式浏览器全部支持；只有get 请求；请求的域可能不安全；不好确定JSONP请求是否失败；</p></blockquote><p>依赖没有同源限制的通信协议：</p><ul><li><strong>WebSocket</strong>：长时通信技术。</li><li><strong>CORS</strong>：跨域资源共享，W3C标准。</li></ul><h3 id="jsonp" tabindex="-1">JSONP <a class="header-anchor" href="#jsonp" aria-label="Permalink to &quot;JSONP&quot;">​</a></h3><p>原理：浏览器能够加载非同源JS脚本，并将返回的脚本内容在浏览器下执行。</p><p>因此，当浏览器加载下面JS时，可使服务器返回<code>hello(data)</code>，从而在浏览器执行该回调函数。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://localhost:8080/?callback=hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>简单实现：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> jsonp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> url </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> req.url </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;?callback=&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> req.callback.name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    script.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> url;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;head&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="cors" tabindex="-1">CORS <a class="header-anchor" href="#cors" aria-label="Permalink to &quot;CORS&quot;">​</a></h3><p>定义了浏览器与服务器如何实现跨源通信。基本思路是使用自定义的HTTP头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。</p><blockquote><p>所有浏览器都支持该功能，IE浏览器不能低于IE10。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p></blockquote><p>浏览器将CORS请求分成两类：简单请求和非简单请求。</p><p><strong>简单请求</strong>：一般指<code>GET</code>、<code>POST</code>请求。 此时，浏览器直接发出CORS请求。具体来说，在头信息之中增加一个<code>Origin</code>字段。</p><p><strong>非简单请求</strong>：<code>PUT</code>、<code>DELETE</code>请求，或者<code>Content-Type</code>字段为<code>application/json</code>。</p><p>此时，浏览器会先通过<code>Options</code>方法发送<strong>预检请求</strong>，询问服务器，是否允许该域名，以及可以使用哪些HTTP动词和头信息字段。</p><p>请求通过后，以后每次浏览器相同类型的CORS请求，都跟简单请求一样。</p><h3 id="请求凭据" tabindex="-1">请求凭据 <a class="header-anchor" href="#请求凭据" aria-label="Permalink to &quot;请求凭据&quot;">​</a></h3><p>默认情况下，<mark>跨源请求不提供凭据</mark>（cookie、HTTP认证和客户端SSL证书）。可以通过将withCredentials属性设置为true来表明请求会发送凭据。</p><h2 id="fetch" tabindex="-1">Fetch <a class="header-anchor" href="#fetch" aria-label="Permalink to &quot;Fetch&quot;">​</a></h2><p>基于XMLHttpRequest的异步通信方式。</p><ul><li><p>语法简洁，更加语义化</p></li><li><p>基于标准 Promise 实现，支持 async/await</p></li><li><p>同构方便。</p></li><li><p>不支持超时控制。</p></li><li><p>比较底层，api较为复杂</p></li></ul><h2 id="axios" tabindex="-1">Axios <a class="header-anchor" href="#axios" aria-label="Permalink to &quot;Axios&quot;">​</a></h2><p>基于 promise 的 HTTP 库。</p><ul><li>简单易用，api接近于jquery，比fetch的简单。</li><li>浏览器兼容性好，能兼容IE7。</li><li>通用性好，能在node和浏览器中使用，api一致。</li></ul><h1 id="登录鉴权" tabindex="-1">登录鉴权 <a class="header-anchor" href="#登录鉴权" aria-label="Permalink to &quot;登录鉴权&quot;">​</a></h1><h2 id="session" tabindex="-1">Session <a class="header-anchor" href="#session" aria-label="Permalink to &quot;Session&quot;">​</a></h2><p>存储用户信息也可以通过Session，其存储在服务器端，会更加安全。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><blockquote><p>浏览器禁用 Cookie下，可以将 Session ID 作为 URL 的参数进行传递。</p></blockquote><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="cookie-session" tabindex="-1">Cookie &amp; Session <a class="header-anchor" href="#cookie-session" aria-label="Permalink to &quot;Cookie &amp; Session&quot;">​</a></h3><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h1 id="服务端推送" tabindex="-1">服务端推送 <a class="header-anchor" href="#服务端推送" aria-label="Permalink to &quot;服务端推送&quot;">​</a></h1><p>用于某些情景的实时推送，如工业运行监控、Web 在线通讯、即时报价系统。</p><h2 id="基于http" tabindex="-1">基于HTTP <a class="header-anchor" href="#基于http" aria-label="Permalink to &quot;基于HTTP&quot;">​</a></h2><p>HTTP是半双工协议。也就是说，在同一时刻数据只能单向流动，客户端向服务器发送请求(单向的)，然后服务器响应请求。<mark>服务器不能主动推送数据</mark>给浏览器。</p><h3 id="_1-轮询-polling" tabindex="-1">1.轮询（polling） <a class="header-anchor" href="#_1-轮询-polling" aria-label="Permalink to &quot;1.轮询（polling）&quot;">​</a></h3><p>客户端每隔一段时间向服务器请求数据。</p><ul><li>优点：实现简单，无需做过多的更改</li><li>缺点：轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担</li></ul><h3 id="_2-长轮询-long-polling" tabindex="-1">2.长轮询（long-polling） <a class="header-anchor" href="#_2-长轮询-long-polling" aria-label="Permalink to &quot;2.长轮询（long-polling）&quot;">​</a></h3><p>客户端请求数据，服务器hold住连接，一直到有数据或者超时才返回。</p><ul><li>优点：比 Polling 做了优化，有较好的时效性</li><li>缺点：保持连接会消耗资源; 程序超时时，服务器没有返回有效数据。</li></ul><h3 id="_3-iframe流-streaming" tabindex="-1">3.iframe流（streaming） <a class="header-anchor" href="#_3-iframe流-streaming" aria-label="Permalink to &quot;3.iframe流（streaming）&quot;">​</a></h3><p>在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接。</p><ul><li>优点：消息能够<mark>实时到达</mark>；浏览器兼容好。</li><li>缺点：服务器维护一个长连接会增加开销。</li></ul><h2 id="websocket" tabindex="-1">WebSocket <a class="header-anchor" href="#websocket" aria-label="Permalink to &quot;WebSocket&quot;">​</a></h2><p>建立在单个TCP连接上，可进行<mark>全双工通信的应用层协议</mark>。只要建立起WebSocket连接，就会一直保持连接状态，直到其中一方断开连接。</p><p>特点：</p><ul><li>支持双向通信，实时性更强</li><li>可以发送文本，也可以发送二进制数据</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>与 HTTP 协议有着良好的兼容性。握手阶段采用 HTTP 协议。</li><li>没有同源限制，客户端可以与任意服务器通信。</li></ul><p>协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws://example.com:80/some/path</span></span></code></pre></div><p><img src="`+e+'" alt="image"></p><h3 id="socket-io" tabindex="-1">Socket.IO <a class="header-anchor" href="#socket-io" aria-label="Permalink to &quot;Socket.IO&quot;">​</a></h3><p>面向实时 web 应用的 JavaScript 库，能够实现服务器和客户端之间的双向通信。<mark>主要使用WebSocket协议</mark>。但是如果需要的话，Socket.io可以回退到几种其它方法，如JSONP拉取，或是传统的AJAX拉取。</p><p>Socket.IO的服务端和客户端必须配套。</p><h1 id="部署架构" tabindex="-1">部署架构 <a class="header-anchor" href="#部署架构" aria-label="Permalink to &quot;部署架构&quot;">​</a></h1><h2 id="web服务器" tabindex="-1">Web服务器 <a class="header-anchor" href="#web服务器" aria-label="Permalink to &quot;Web服务器&quot;">​</a></h2><p>对于传统的客户端 - 服务器架构，服务器的作用是：接收请求、处理请求、返回响应。Web服务器是一类特殊的服务器，其作用是主要是接收 HTTP 请求并返回响应。常见的 web服务器有 Nginx，Apache，IIS等。</p><h2 id="web框架" tabindex="-1">Web框架 <a class="header-anchor" href="#web框架" aria-label="Permalink to &quot;Web框架&quot;">​</a></h2><p>开发web应用的框架。</p><h2 id="wsgi" tabindex="-1">WSGI <a class="header-anchor" href="#wsgi" aria-label="Permalink to &quot;WSGI&quot;">​</a></h2><p>一个协议，定义了 web服务器和 web应用之间的接口规范。’</p><p>名词区分：</p><ul><li><strong>uwsgi</strong>：同 wsgi 一样也是一种协议。</li><li><strong>uWSGI</strong>：实现了 uwsgi 和 WSGI 两种协议的web服务器。</li></ul><p><img src="'+t+'" alt="image"></p><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1>',94)])])}const u=i(h,[["render",p]]);export{g as __pageData,u as default};
