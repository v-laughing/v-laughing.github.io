import{_ as i,c as a,o as n,a4 as t}from"./chunks/framework.DQcV7ckZ.js";const e="/assets/hmr-websocket.CD6ez6O8.webp",E=JSON.parse('{"title":"HMR","description":"","frontmatter":{"title":"HMR"},"headers":[],"relativePath":"cs/web-build/HMR.md","filePath":"cs/web-build/HMR.md"}'),h={name:"cs/web-build/HMR.md"};function l(p,s,k,d,o,r){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="hmr" tabindex="-1">HMR <a class="header-anchor" href="#hmr" aria-label="Permalink to &quot;HMR&quot;">​</a></h1><p>HMR 全称 Hot Module Replacement，可以翻译为「<strong>模块热更新</strong>」，最初由 Webpack 设计实现，至今已几乎成为现代工程化必备工具之一，它能够在保持页面状态不变的情况下动态替换、删除、添加代码模块，提供超级丝滑顺畅的 Web 页面开发体验。</p><p>在 HMR 之前，应用的加载、更新都是一种页面级别的原子操作，即使只是单个代码文件发生变更，都需要刷新整个页面，才能将最新代码映射到浏览器上，这会丢失之前在页面执行过的所有交互与状态，例如：</p><ul><li>对于复杂表单场景，这意味着你可能需要重新填充非常多字段信息；</li><li>弹框消失，你必须重新执行交互动作才会重新弹出。</li></ul><h2 id="webpack-使用-hmr" tabindex="-1">Webpack 使用 HMR <a class="header-anchor" href="#webpack-使用-hmr" aria-label="Permalink to &quot;Webpack 使用 HMR&quot;">​</a></h2><ol><li>设置 <code>devServer.hot</code> 属性为 true：</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack.config.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  devServer: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 必须设置 devServer.hot = true，启动 HMR 功能</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hot: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><ol start="2"><li>在代码中调用 <code>module.hot.accept</code> 接口，<mark>声明如何将模块安全地替换为最新代码</mark>，如：</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> component </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./component&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> demoComponent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(demoComponent);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// HMR interface</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Capture hot update</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./component&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Replace old content with the hot loaded one</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextComponent, demoComponent);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    demoComponent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextComponent;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="webpack-hmr-实现原理" tabindex="-1">Webpack HMR 实现原理 <a class="header-anchor" href="#webpack-hmr-实现原理" aria-label="Permalink to &quot;Webpack HMR 实现原理&quot;">​</a></h2><p>Webpack HMR 特性的执行过程并不复杂，核心步骤如下：</p><ol><li>使用 <code>webpack-dev-server</code> （后面简称 WDS）托管静态资源，同时以 Runtime 方式注入一段处理 HMR 逻辑的客户端代码；</li><li>浏览器加载页面后，与 WDS 建立 WebSocket 连接；</li><li>Webpack 监听到文件变化后，增量构建发生变更的模块，并通过 WebSocket 发送 <code>hash</code> 事件；</li><li>浏览器接收到 <code>hash</code> 事件后，请求 <code>manifest</code> 资源文件，确认增量变更范围；</li><li>浏览器加载发生变更的增量模块；</li><li>Webpack 运行时触发变更模块的 <code>module.hot.accept</code> 回调，执行代码变更逻辑；</li></ol><p>具体过程如下：</p><p><img src="`+e+`" alt="image.png"></p><ol><li><p><strong>注入 HMR 客户端运行时</strong>：在 HMR 场景下，执行 <code>npx webpack serve</code> 命令后，<code>webpack-dev-server</code> 首先会调用 <code>HotModuleReplacementPlugin</code> 插件向应用的主 Chunk 注入一系列 HMR Runtime，包括：</p><ul><li>用于建立 WebSocket 连接，处理 <code>hash</code> 等消息的运行时代码；</li><li>用于加载热更新资源的 <code>RuntimeGlobals.hmrDownloadManifest</code> 与 <code>RuntimeGlobals.hmrDownloadUpdateHandlers</code> 接口；</li><li>用于处理模块更新策略的 <code>module.hot.accept</code> 接口；</li></ul></li></ol><p>除注入客户端代码外，<code>HotModuleReplacementPlugin</code> 插件还会借助 Webpack 的 <code>watch</code> 能力，在代码文件发生<mark>变化后执行增量构建</mark>，生成：</p><ul><li><code>manifest</code> 文件：JSON 格式文件，<mark>包含所有发生变更的模块列表</mark>，命名为 <code>[hash].hot-update.json</code>；</li><li>模块变更文件：js 格式，包含编译后的模块代码，命名为 <code>[hash].hot-update.js</code>。</li></ul><p>增量构建完毕后，Webpack 将触发 <code>compilation.hooks.done</code> 钩子，并传递本次构建的统计信息对象 <code>stats</code>。WDS 则监听 <code>done</code> 钩子，在回调中通过 WebSocket 发送模块更新消息：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hash&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${stats.hash}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li><strong>加载更新</strong>：客户端通过 WebSocket 接收到 <code>hash</code> 消息后，首先发出 <code>manifest</code> 请求获取本轮热更新涉及的 chunk。</li></ol><blockquote><p>注意：在 Webpack 4 及之前，热更新文件以模块为单位，即所有发生变化的模块都会生成对应的热更新文件； Webpack 5 之后热更新文件以 chunk 为单位，如上例中，<code>main</code> chunk 下任意文件的变化都只会生成 <code>main.[hash].hot-update.js</code> 更新文件。</p></blockquote><p><code>manifest</code> 请求完成后，客户端 HMR 运行时开始下载发生变化的 chunk 文件，将最新模块代码加载到本地。</p><ol start="3"><li><strong>执行 <code>module.hot.accept</code> 回调</strong>：经过上述步骤，浏览器加载完最新模块代码后，HMR 运行时会继续触发 <code>module.hot.accept</code> 回调，将最新代码替换到运行环境中。</li></ol><h2 id="module-hot-accept" tabindex="-1"><code>module.hot.accept</code> <a class="header-anchor" href="#module-hot-accept" aria-label="Permalink to &quot;\`module.hot.accept\`&quot;">​</a></h2><p><code>module.hot.accept</code> 用于<mark>自定义模块热替换的逻辑</mark>，定义如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> string, callback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li><code>path</code>：指定需要拦截变更行为的模块路径；</li><li><code>callback</code>：模块更新后，将最新模块代码应用到运行环境的函数。</li></ul><p>例如，对于如下代码：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/bar.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bar&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/index.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { bar } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node.innerText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./bar.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    node.innerText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p><code>module.hot.accept</code> 函数监听 <code>./bar.js</code> 模块的变更事件，一旦代码发生变动，就触发回调，将 <code>./bar.js</code> 导出的值替换到页面上，从而实现热更新效果。</p><h3 id="accept-函数注意事项" tabindex="-1"><code>accept</code> 函数注意事项 <a class="header-anchor" href="#accept-函数注意事项" aria-label="Permalink to &quot;\`accept\` 函数注意事项&quot;">​</a></h3><ul><li><p><strong>处理失败兜底逻辑</strong>：一旦某个模块没有注册对应的 <code>module.hot.accept</code> 函数后，HMR 运行时会执行兜底策略，通常是刷新页面。</p></li><li><p><strong>更新事件冒泡</strong>：<code>module.hot.accept</code> 函数只能捕获<mark>该模块及其子孙模块</mark>的更新事件。</p></li><li><p><strong>使用无参数调用风格</strong>：<code>module.hot.accept</code> 函数支持无参数调用风格，作用是捕获当前文件的变更事件，并<mark>重新运行</mark>该模块的代码。</p></li></ul><h2 id="vite-使用-hmr" tabindex="-1">Vite 使用 HMR <a class="header-anchor" href="#vite-使用-hmr" aria-label="Permalink to &quot;Vite 使用 HMR&quot;">​</a></h2><p>Vite 的 HMR API 基于 ESM 标准设计，通过 <code>import.meta.hot</code> 对象暴露。</p><ol><li><p>在 <code>vite.config.js</code> 中通常无需额外配置，Vite 默认启用 HMR。</p></li><li><p>在代码中通过 <code>import.meta.hot</code> 接口处理热更新逻辑：</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { render } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./render.js&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 接受 ./render.js 模块的更新</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./render.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newModule.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="vite-hmr-实现原理" tabindex="-1">Vite HMR 实现原理 <a class="header-anchor" href="#vite-hmr-实现原理" aria-label="Permalink to &quot;Vite HMR 实现原理&quot;">​</a></h2><p>Vite 的 HMR 实现与 Webpack 有本质区别，它<mark>利用了浏览器原生的 ESM (ES Modules) 能力</mark>。</p><ol><li><strong>服务端</strong>：Vite 创建一个 WebSocket 服务端，同时监听文件系统的变化。</li><li><strong>客户端</strong>：Vite 在开发环境中注入客户端代码（<code>@vite/client</code>），与服务端建立 WebSocket 连接。</li><li><strong>消息推送</strong>：当文件发生修改时，服务端计算出受影响的模块，通过 WebSocket 向客户端发送 <code>update</code> 消息。</li><li><strong>浏览器加载</strong>：客户端收到更新消息后，通过动态 <code>import()</code> 重新请求更新后的模块。Vite 会在 URL 后添加时间戳（如 <code>?t=123</code>）以<mark>防止浏览器缓存</mark>。</li><li><strong>回调执行</strong>：新模块加载完成后，触发 <code>import.meta.hot.accept</code> 定义的回调，进行热替换。</li></ol><p>核心优势在于<mark>Vite 无需重新构建 Bundle</mark>。Webpack 的 HMR 需要重新编译模块并生成补丁 chunk，而 Vite 只需要让浏览器重新请求变更的单个文件，因此在大型项目中 HMR 速度优势明显。</p><h2 id="import-meta-hot-accept" tabindex="-1"><code>import.meta.hot.accept</code> <a class="header-anchor" href="#import-meta-hot-accept" aria-label="Permalink to &quot;\`import.meta.hot.accept\`&quot;">​</a></h2><p>Vite 中使用 <code>import.meta.hot.accept</code> 来<mark>定义接受更新的策略</mark>。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ImportMetaHot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  accept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">deps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mods</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>接受自身</strong>：<code>import.meta.hot.accept((newModule) =&gt; { ... })</code> 模块接受自身的更新。如果不传回调，模块更新时会冒泡到父模块。</li><li><strong>接受依赖</strong>：<code>import.meta.hot.accept(&#39;./dep.js&#39;, (newDep) =&gt; { ... })</code> 父模块接受子模块的更新，并在回调中处理副作用（如重新渲染）。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>综上，HMR 是提升开发体验的核心技术。</p><ul><li><strong>Webpack HMR</strong>：基于 Bundle，监听文件变化 -&gt; 增量构建 -&gt; 生成 Manifest 和 Update Chunk -&gt; 客户端请求差异 -&gt; <code>module.hot.accept</code> 更新。</li><li><strong>Vite HMR</strong>：基于 Native ESM，监听文件变化 -&gt; 推送 Update 消息 -&gt; 浏览器重新请求单文件 -&gt; <code>import.meta.hot.accept</code> 更新。</li></ul><p>两者虽然实现机制不同（Bundless vs Bundle），但本质都是通过 WebSocket 通信配合客户端 API 来实现页面状态保持下的代码热替换。</p>`,48)])])}const g=i(h,[["render",l]]);export{E as __pageData,g as default};
