import{_ as o,c as r,o as n,a4 as a,j as t,a as s}from"./chunks/framework.DQgBWl2g.js";const k=JSON.parse('{"title":"正则表达式","description":"","frontmatter":{},"headers":[],"relativePath":"cs/Lang/regex.md","filePath":"cs/Lang/regex.md"}'),l={name:"cs/Lang/regex.md"};function d(i,e,c,h,g,p){return n(),r("div",null,[...e[0]||(e[0]=[a('<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to &quot;正则表达式&quot;">​</a></h1><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p><h1 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h1><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。正则表达式是大小写敏感的。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>`the` =&gt; The fat cat sat on the mat.</span></span></code></pre></div><h2 id="元字符" tabindex="-1">元字符 <a class="header-anchor" href="#元字符" aria-label="Permalink to &quot;元字符&quot;">​</a></h2><p>正则表达式主要依赖于元字符，其拥有特殊的文本含义。</p>',7),t("table",{tabindex:"0"},[t("thead",null,[t("tr",null,[t("th",{style:{"text-align":"center"}},"元字符"),t("th",null,"描述")])]),t("tbody",null,[t("tr",null,[t("td",{style:{"text-align":"center"}},"."),t("td",null,"句号匹配任意单个字符除了换行符。")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"[ ]"),t("td",null,"字符种类。匹配方括号内的任意字符。")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"[^ ]"),t("td",null,"否定的字符种类。匹配除了方括号里的任意字符")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"*"),t("td",null,"匹配>=0个重复的在*号之前的字符。")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"+"),t("td",null,"匹配>=1个重复的+号前的字符。")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"?"),t("td",null,"标记?之前的字符为可选.")]),t("tr",null,[t("td",{style:{"text-align":"center"},"n,m":""}),t("td",null,"匹配num个大括号之前的字符或字符集 (n <= num <= m).")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"(xyz)"),t("td",null,"字符集，匹配与 xyz 完全相等的字符串.")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"|"),t("td",null,"或运算符，匹配符号前或后的字符.")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"\\"),t("td",null,[s("转义字符,用于匹配一些保留的字符 "),t("code",null,"[ ] ( ) { } . * + ? ^ $ \\ |")])]),t("tr",null,[t("td",{style:{"text-align":"center"}},"^"),t("td",null,"从开始行开始匹配.")]),t("tr",null,[t("td",{style:{"text-align":"center"}},"$"),t("td",null,"从末端开始匹配.")])])],-1),a('<h3 id="转义特殊字符" tabindex="-1">转义特殊字符 <a class="header-anchor" href="#转义特殊字符" aria-label="Permalink to &quot;转义特殊字符&quot;">​</a></h3><p>反斜线 <code>\\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \\ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\\</code>。</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\\.</code> 以下这个例子 <code>\\.?</code>是选择性匹配<code>.</code></p><blockquote><p><code>(f|c|m)at\\.?</code> =&gt; The <strong>fat</strong> <strong>cat</strong> sat on the <strong>mat.</strong></p></blockquote><h2 id="点运算符" tabindex="-1">点运算符 <a class="header-anchor" href="#点运算符" aria-label="Permalink to &quot;点运算符&quot;">​</a></h2><blockquote><p><code>.ar</code> =&gt; The <strong>car</strong> <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h2 id="字符集" tabindex="-1">字符集 <a class="header-anchor" href="#字符集" aria-label="Permalink to &quot;字符集&quot;">​</a></h2><p>方括号用来指定一个字符集。可以使用连字符来指定字符集的范围。</p><blockquote><p><code>[Tt]he</code> =&gt; <strong>The</strong> car parked in <strong>the</strong> garage.</p></blockquote><p>方括号中没有元字符，因此句号不用转义。</p><blockquote><p><code>ar[.]</code> =&gt; A garage is a good place to park a c<strong>ar.</strong></p></blockquote><h3 id="否定字符集" tabindex="-1">否定字符集 <a class="header-anchor" href="#否定字符集" aria-label="Permalink to &quot;否定字符集&quot;">​</a></h3><p>以<code>^</code>开头的方括号，表示这个字符集是否定的。</p><blockquote><p><code>[^c]ar</code> =&gt; The car <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h3 id="简写字符集" tabindex="-1">简写字符集 <a class="header-anchor" href="#简写字符集" aria-label="Permalink to &quot;简写字符集&quot;">​</a></h3><p>正则表达式提供一些常用的字符集简写。如下:</p><table tabindex="0"><thead><tr><th style="text-align:center;">简写</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">.</td><td>除换行符外的所有字符</td></tr><tr><td style="text-align:center;">\\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9\\_]</code></td></tr><tr><td style="text-align:center;">\\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\\w]</code></td></tr><tr><td style="text-align:center;">\\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td style="text-align:center;">\\D</td><td>匹配非数字： <code>[^\\d]</code></td></tr><tr><td style="text-align:center;">\\s</td><td>匹配所有空格字符，等同于： <code>[\\t\\n\\f\\r\\p{Z}]</code></td></tr><tr><td style="text-align:center;">\\S</td><td>匹配所有非空格字符： <code>[^\\s]</code></td></tr><tr><td style="text-align:center;">\\f</td><td>匹配一个换页符</td></tr><tr><td style="text-align:center;">\\n</td><td>匹配一个换行符</td></tr><tr><td style="text-align:center;">\\r</td><td>匹配一个回车符</td></tr><tr><td style="text-align:center;">\\t</td><td>匹配一个制表符</td></tr><tr><td style="text-align:center;">\\v</td><td>匹配一个垂直制表符</td></tr><tr><td style="text-align:center;">\\p</td><td>匹配 CR/LF（等同于 <code>\\r\\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="重复匹配" tabindex="-1">重复匹配 <a class="header-anchor" href="#重复匹配" aria-label="Permalink to &quot;重复匹配&quot;">​</a></h2><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。</p><blockquote><p><code>[a-z]*</code> =&gt; T<strong>he</strong> <strong>car</strong> <strong>parked</strong> <strong>in</strong> <strong>the</strong> <strong>garage</strong> #21.</p></blockquote><blockquote><p><code>c.+t</code> =&gt; The fat <strong>cat sat on the mat</strong>.</p></blockquote><blockquote><p><code>[T]?he</code> =&gt; <strong>The</strong> car is parked in t<strong>he</strong> garage.</p></blockquote><h3 id="量词匹配" tabindex="-1">量词匹配 <a class="header-anchor" href="#量词匹配" aria-label="Permalink to &quot;量词匹配&quot;">​</a></h3><ul><li><strong>{n}</strong> 匹配 n 个字符</li><li><strong>{m,n}</strong> 匹配 m~n 个字符</li><li><strong>{m,}</strong> 至少匹配 m 个字符</li></ul><blockquote><p><code>[0-9]{2,3}</code> =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to <strong>10</strong>.0.</p></blockquote><h2 id="子表达式" tabindex="-1">子表达式 <a class="header-anchor" href="#子表达式" aria-label="Permalink to &quot;子表达式&quot;">​</a></h2><p>使用 <strong>( )</strong> 定义一个子表达式。子表达式的内容可以当成一个整体，即可以将它看成一个字符。</p><p><strong>|</strong> 是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。</p><blockquote><p><code>(c|g|p)ar</code> =&gt; The <strong>car</strong> is <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h2 id="位置匹配" tabindex="-1">位置匹配 <a class="header-anchor" href="#位置匹配" aria-label="Permalink to &quot;位置匹配&quot;">​</a></h2><p><strong>^</strong> 匹配整个字符串的开头，<strong>$</strong> 匹配结尾。从开头或从结尾开始匹配。</p><blockquote><p><code>^(T|t)he</code> =&gt; <strong>The</strong> car is parked in the garage.</p></blockquote><blockquote><p><code>(at\\.)$</code> =&gt; The fat cat. sat. on the m<strong>at.</strong></p></blockquote><h3 id="单词边界" tabindex="-1">单词边界 <a class="header-anchor" href="#单词边界" aria-label="Permalink to &quot;单词边界&quot;">​</a></h3><p><strong>\\b</strong> 可以匹配一个单词的边界，边界是指位于 \\w 和 \\W 之间的位置；<strong>\\B</strong> 匹配一个不是单词边界的位置。</p><p>\\b 只匹配位置，不匹配字符，因此 \\babc\\b 匹配出来的结果为 3 个字符。</p><h2 id="前后预查" tabindex="-1">前后预查 <a class="header-anchor" href="#前后预查" aria-label="Permalink to &quot;前后预查&quot;">​</a></h2><p>先行声明和后发声明都属于<strong>非捕获簇</strong>（不捕获文本 ，也不针对组合计进行计数）。</p><p>零宽度声明有：</p><table tabindex="0"><thead><tr><th style="text-align:center;">符号</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">?=</td><td>正先行声明-存在</td></tr><tr><td style="text-align:center;">?!</td><td>负先行声明-排除</td></tr><tr><td style="text-align:center;">?&lt;=</td><td>正后发声明-存在</td></tr><tr><td style="text-align:center;">?&lt;!</td><td>负后发声明-排除</td></tr></tbody></table><p>需定义在括号内。</p><h3 id="正先行声明" tabindex="-1">正先行声明 <a class="header-anchor" href="#正先行声明" aria-label="Permalink to &quot;正先行声明&quot;">​</a></h3><p><code>?=...</code> 正先行声明，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。返回结果只包含满足匹配条件的第一部分表达式。</p><blockquote><p><code>(T|t)he(?=\\sfat)</code> =&gt; <strong>The</strong> fat cat sat on the mat.</p></blockquote><h3 id="负先行声明" tabindex="-1">负先行声明 <a class="header-anchor" href="#负先行声明" aria-label="Permalink to &quot;负先行声明&quot;">​</a></h3><p>负先行声明 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着声明中定义的格式。</p><blockquote><p><code>(T|t)he(?!\\sfat)</code> =&gt; The fat cat sat on <strong>the</strong> mat.</p></blockquote><h3 id="正后发声明" tabindex="-1">正后发声明 <a class="header-anchor" href="#正后发声明" aria-label="Permalink to &quot;正后发声明&quot;">​</a></h3><p>筛选其前跟随着声明中定义的格式。</p><blockquote><p><code>(?&lt;=(T|t)he\\s)(fat|mat)</code> =&gt; The <strong>fat</strong> cat sat on the <strong>mat</strong>.</p></blockquote><h3 id="负后发声明" tabindex="-1">负后发声明 <a class="header-anchor" href="#负后发声明" aria-label="Permalink to &quot;负后发声明&quot;">​</a></h3><blockquote><p><code>(?&amp;lt;!(T|t)he\\s)(cat)</code> =&gt; The cat sat on <strong>cat</strong>.</p></blockquote><h1 id="模式与标志" tabindex="-1">模式与标志 <a class="header-anchor" href="#模式与标志" aria-label="Permalink to &quot;模式与标志&quot;">​</a></h1><h2 id="贪婪匹配与惰性匹配" tabindex="-1">贪婪匹配与惰性匹配 <a class="header-anchor" href="#贪婪匹配与惰性匹配" aria-label="Permalink to &quot;贪婪匹配与惰性匹配&quot;">​</a></h2><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><blockquote><p><code>(.*at)/</code> =&gt; <strong>The fat cat sat on the mat</strong>.</p></blockquote><blockquote><p><code>(.*?at)/</code> =&gt; <strong>The fat</strong> cat sat on the mat.</p></blockquote><h2 id="标志" tabindex="-1">标志 <a class="header-anchor" href="#标志" aria-label="Permalink to &quot;标志&quot;">​</a></h2><p>模式修正符，附加的搜索条件。</p><table tabindex="0"><thead><tr><th style="text-align:center;">标志</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;">i</td><td>忽略大小写。</td></tr><tr><td style="text-align:center;">g</td><td>全局搜索。</td></tr><tr><td style="text-align:center;">m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table><blockquote><p><code>/The/gi</code> =&gt; <strong>The</strong> fat cat sat on <strong>the</strong> mat.</p></blockquote><blockquote><p><code>/.at(.)?$/</code> =&gt; The fat \\n cat sat \\n on the <strong>mat.</strong></p></blockquote><blockquote><p><code>/.at(.)?$/gm</code> =&gt; The <strong>fat</strong> \\n cat <strong>sat</strong> \\n on the <strong>mat.</strong></p></blockquote><h1 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h1><h2 id="常见正则" tabindex="-1">常见正则 <a class="header-anchor" href="#常见正则" aria-label="Permalink to &quot;常见正则&quot;">​</a></h2><p><strong>手机号</strong>：<code>^1[34578]\\d{9}$</code></p><p><strong>邮箱</strong>：<code>^[\\w\\-]+@[\\w\\-]+\\.[\\w\\-]+$</code></p><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><h3 id="千位符" tabindex="-1">千位符 <a class="header-anchor" href="#千位符" aria-label="Permalink to &quot;千位符&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;7907899.00&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)(?=(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">{3}</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+\\b</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;$1,&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>',70)])])}const b=o(l,[["render",d]]);export{k as __pageData,b as default};
