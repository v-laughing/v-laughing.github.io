import{_ as i,c as s,o as e,a4 as l}from"./chunks/framework.DQgBWl2g.js";const t="/assets/b396d726-b75f-4a32-89a2-03a7b6e19f6f.CgTQENeT.jpg",n="/assets/47d98583-8bb0-45cc-812d-47eefa0a4a40.CuA4ZziA.jpg",p="/assets/76dc7769-1aac-4888-9bea-064f1caa8e77.4f72R9NQ.jpg",b=JSON.parse('{"title":"基本原理","description":"","frontmatter":{"title":"基本原理"},"headers":[],"relativePath":"cs/compile/index.md","filePath":"cs/compile/index.md"}'),o={name:"cs/compile/index.md"};function h(d,a,c,r,k,u){return e(),s("div",null,[...a[0]||(a[0]=[l(`<h2 id="编译过程" tabindex="-1">编译过程 <a class="header-anchor" href="#编译过程" aria-label="Permalink to &quot;编译过程&quot;">​</a></h2><p>以下是一个 hello.c 程序：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello, world</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gcc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello.c</span></span></code></pre></div><p>这个过程大致如下：</p><p><img src="`+t+'" alt="avatar"><br></p><h4 id="预处理阶段" tabindex="-1">预处理阶段 <a class="header-anchor" href="#预处理阶段" aria-label="Permalink to &quot;预处理阶段&quot;">​</a></h4><p>程序预处理，主要处理源码中的以<code>#</code>开始的预编译指令，如<code>#include</code>、<code>#define</code>等。</p><ul><li>根据<code>#define</code>宏定义替换，根据<code>#include</code>递归将整个文件包含进来。</li><li>删除所有注释，并添加行号和文件名。</li><li>保留所有的#pragma编译器指令。</li></ul><h4 id="编译阶段" tabindex="-1">编译阶段 <a class="header-anchor" href="#编译阶段" aria-label="Permalink to &quot;编译阶段&quot;">​</a></h4><p>把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件。</p><blockquote><p>汇编文件中通过符号<code>Symbol</code>来定位函数或一些变量的地址。对于内联的符号，会在汇编阶段被重新计算为虚拟地址，对于外联符号，会在链接阶段被重定位。</p></blockquote><h4 id="汇编阶段" tabindex="-1">汇编阶段 <a class="header-anchor" href="#汇编阶段" aria-label="Permalink to &quot;汇编阶段&quot;">​</a></h4><p>将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。</p><p>此阶段产生的一般称为<strong>可重定位目标文件</strong>，在Windows下，可以统称为PE-COFF文件格式。在Linux下，被统称为ELF文件。</p><p>该目标文件主要包含：机器指令代码、数据、符号表等。</p><p>文件中的内容以「段」的形式存储，不同段存储不同内容。</p><p><code>.code</code>或<code>.text</code>： 机器指令。</p><p><code>.data</code>：已初始化的全局变量和局部静态变量。</p><p><code>.bss</code>：未初始化的全局变量和局部静态变量，此时默认值为0，因而该字段初始时并未给变量分配内容。</p><p><code>.rodata</code>：只读数据，如const变量或字符串常量。</p><p><code>.symtab</code>：符号表，包含符号及其地址。</p><h4 id="链接阶段" tabindex="-1">链接阶段 <a class="header-anchor" href="#链接阶段" aria-label="Permalink to &quot;链接阶段&quot;">​</a></h4><p>将可多个重定位目标文件进行合并，得到最终的可执行目标文件。每个目标文件都维护着一个符号表，此过程的主要目的即是确定各个符号的值（地址）。</p><p>符号分为三种：</p><ul><li>全局符号：由本模块定义并能被其他模块引用。如非静态的 C 函数和全局变量。</li><li>外部符号：非本模块定义，引用其他模块。</li><li>本地符号：在本模块定义，只能被本模块引用。如静态的 C 函数和全局变量。</li></ul><p>合并过程中可能产生符号「重复定义」问题。编译器将函数和初始化了的全局变量定义为<strong>强符号</strong>，未初始化的全局变量为<strong>弱符号</strong>，并遵守以下规则：</p><ul><li>不允许强符号被多次定义。</li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li><li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li></ul><h1 id="静态链接" tabindex="-1">静态链接 <a class="header-anchor" href="#静态链接" aria-label="Permalink to &quot;静态链接&quot;">​</a></h1><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><p><img src="'+n+'" alt="avatar"><br></p><h1 id="动态链接" tabindex="-1">动态链接 <a class="header-anchor" href="#动态链接" aria-label="Permalink to &quot;动态链接&quot;">​</a></h1><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><p><img src="'+p+'" alt="avatar"><br></p>',39)])])}const E=i(o,[["render",h]]);export{b as __pageData,E as default};
