import{_ as t,c as e,o as r,a4 as o}from"./chunks/framework.DdddRsJj.js";const n="/assets/tGPV0.BwJJJ8du.png",l="/assets/2_14_microkernelArchitecture.CRNi8x9t.jpg",k=JSON.parse('{"title":"基本特征","description":"","frontmatter":{},"headers":[],"relativePath":"cs/Osystem/concept.md","filePath":"cs/Osystem/concept.md"}'),i={name:"cs/Osystem/concept.md"};function h(d,a,s,p,c,m){return r(),e("div",null,[...a[0]||(a[0]=[o('<h1 id="基本特征" tabindex="-1">基本特征 <a class="header-anchor" href="#基本特征" aria-label="Permalink to &quot;基本特征&quot;">​</a></h1><h2 id="_1-并发" tabindex="-1">1. 并发 <a class="header-anchor" href="#_1-并发" aria-label="Permalink to &quot;1. 并发&quot;">​</a></h2><p><strong>并发</strong>：宏观上在<mark>一段时间内</mark>能同时多个程序。多个程序<mark>交替运行</mark>。</p><blockquote><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p></blockquote><p><strong>并行</strong>：同一时刻能运行多个程序。</p><blockquote><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p></blockquote><h2 id="_2-共享" tabindex="-1">2. 共享 <a class="header-anchor" href="#_2-共享" aria-label="Permalink to &quot;2. 共享&quot;">​</a></h2><p>共享是指系统中的资源可以被<mark>多个并发进程</mark>共同使用。</p><p>有两种共享方式：<mark>互斥共享</mark>和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用<mark>同步机制</mark>来实现互斥访问。</p><h2 id="_3-虚拟" tabindex="-1">3. 虚拟 <a class="header-anchor" href="#_3-虚拟" aria-label="Permalink to &quot;3. 虚拟&quot;">​</a></h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时分复用技术和空分复用技术。</p><p><strong>时分复用技术</strong>：多个进程在同一个处理器上并发执行。每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p><strong>空分复用技术</strong>：虚拟内存技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h2 id="_4-异步" tabindex="-1">4. 异步 <a class="header-anchor" href="#_4-异步" aria-label="Permalink to &quot;4. 异步&quot;">​</a></h2><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h2 id="_5-内存" tabindex="-1">5. 内存 <a class="header-anchor" href="#_5-内存" aria-label="Permalink to &quot;5. 内存&quot;">​</a></h2><p><strong>栈</strong>：由编译器自动分配释放的临时，连续的内存区域，存放函数的参数值，局部变量的值。</p><p><strong>堆</strong>：由程序员分配释放的全局，非连续的内存区域，存放创建的对象。</p><h1 id="基本功能" tabindex="-1">基本功能 <a class="header-anchor" href="#基本功能" aria-label="Permalink to &quot;基本功能&quot;">​</a></h1><h2 id="_1-进程管理" tabindex="-1">1. 进程管理 <a class="header-anchor" href="#_1-进程管理" aria-label="Permalink to &quot;1. 进程管理&quot;">​</a></h2><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h2 id="_2-内存管理" tabindex="-1">2. 内存管理 <a class="header-anchor" href="#_2-内存管理" aria-label="Permalink to &quot;2. 内存管理&quot;">​</a></h2><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h2 id="_3-文件管理" tabindex="-1">3. 文件管理 <a class="header-anchor" href="#_3-文件管理" aria-label="Permalink to &quot;3. 文件管理&quot;">​</a></h2><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h2 id="_4-设备管理" tabindex="-1">4. 设备管理 <a class="header-anchor" href="#_4-设备管理" aria-label="Permalink to &quot;4. 设备管理&quot;">​</a></h2><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h1 id="系统调用" tabindex="-1">系统调用 <a class="header-anchor" href="#系统调用" aria-label="Permalink to &quot;系统调用&quot;">​</a></h1><p>如果一个进程<mark>在用户态需要使用内核态的功能</mark>，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><img src="'+n+'" alt="avatar | 600"><br></p><p>Linux 的系统调用主要有以下这些：</p><table tabindex="0"><thead><tr><th style="text-align:center;">Task</th><th>Commands</th></tr></thead><tbody><tr><td style="text-align:center;">进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td style="text-align:center;">进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td style="text-align:center;">文件操作</td><td>open(); read(); write();</td></tr><tr><td style="text-align:center;">设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td style="text-align:center;">信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td style="text-align:center;">安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h1 id="大内核和微内核" tabindex="-1">大内核和微内核 <a class="header-anchor" href="#大内核和微内核" aria-label="Permalink to &quot;大内核和微内核&quot;">​</a></h1><h2 id="_1-大内核" tabindex="-1">1. 大内核 <a class="header-anchor" href="#_1-大内核" aria-label="Permalink to &quot;1. 大内核&quot;">​</a></h2><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h2 id="_2-微内核" tabindex="-1">2. 微内核 <a class="header-anchor" href="#_2-微内核" aria-label="Permalink to &quot;2. 微内核&quot;">​</a></h2><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，<mark>其余模块运行在用户态</mark>。</p><p>因为需要频繁地在用户态和核心态之间进行<mark>切换</mark>，所以会有一定的<mark>性能损失</mark>。</p><p><img src="'+l+'" alt="avatar"><br></p><h1 id="中断分类" tabindex="-1">中断分类 <a class="header-anchor" href="#中断分类" aria-label="Permalink to &quot;中断分类&quot;">​</a></h1><h2 id="_1-外中断" tabindex="-1">1. 外中断 <a class="header-anchor" href="#_1-外中断" aria-label="Permalink to &quot;1. 外中断&quot;">​</a></h2><p>由 <mark>CPU 执行指令以外</mark>的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h2 id="_2-异常" tabindex="-1">2. 异常 <a class="header-anchor" href="#_2-异常" aria-label="Permalink to &quot;2. 异常&quot;">​</a></h2><p>由 <mark>CPU 执行指令的内部事件</mark>引起，如非法操作码、地址越界、算术溢出等。</p><h2 id="_3-陷入" tabindex="-1">3. 陷入 <a class="header-anchor" href="#_3-陷入" aria-label="Permalink to &quot;3. 陷入&quot;">​</a></h2><p>在用户程序中使用系统调用。</p>',51)])])}const u=t(i,[["render",h]]);export{k as __pageData,u as default};
