import{_ as t,c as o,o as a,a4 as i}from"./chunks/framework.DdddRsJj.js";const c="/assets/git-areas.CqiK4BT1.png",r="/assets/git-branch.BGTqHzuy.png",l="/assets/git-branch-merge.B1EhACDS.png",s="/assets/git-rebase.C7_zTC3Y.png",d="/assets/git-reset-checkout.CdMDpJIY.png",n="/assets/7a29acce-f243-4914-9f00-f2988c528412.CHNHdfTg.jpg",f=JSON.parse('{"title":"Git","description":"","frontmatter":{"title":"Git"},"headers":[],"relativePath":"cs/tools/Git.md","filePath":"cs/tools/Git.md"}'),g={name:"cs/tools/Git.md"};function p(h,e,m,u,b,k){return a(),o("div",null,[...e[0]||(e[0]=[i('<h1 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-label="Permalink to &quot;基础&quot;">​</a></h1><p>新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库，存储着所有的提交信息。</p><h2 id="三种状态" tabindex="-1">三种状态 <a class="header-anchor" href="#三种状态" aria-label="Permalink to &quot;三种状态&quot;">​</a></h2><p><strong>Git</strong>将数据划分为三个区域：工作区、暂存区以及 Git 目录。</p><p><strong>工作区</strong>：保存当前正在编辑的文件。</p><p><strong>暂存区</strong>：保存<mark>下次将要提交</mark>的文件列表信息。</p><p><strong>Git 目录</strong>：保存项目的所有元数据和对象数据库的地方，是<strong>Git</strong>的核心。</p><p>三个工作区对应的文件的状态分别是：<strong>已修改</strong>，<strong>已暂存</strong>，<strong>已提交</strong>。</p><p><img src="'+c+'" alt="image"></p><p>根据是否已纳入版本管理，即是否被提交到了git目录，文件可分为<strong>已跟踪</strong>和<strong>未跟踪</strong>两种状态。本地新建的文件都属于<strong>未跟踪</strong>状态。</p><h2 id="基本工作流" tabindex="-1">基本工作流 <a class="header-anchor" href="#基本工作流" aria-label="Permalink to &quot;基本工作流&quot;">​</a></h2><p><strong>新建仓库</strong></p><ol><li>本地项目使用git进行管理：<code>git init</code></li><li>从远程git仓库复制项目：<code>git clone &lt;url&gt;</code></li></ol><p><strong>暂存</strong> 提交文件到暂存区。可使用通配符。</p><ol><li>所有文件：<code>git add .</code></li><li>指定文件：<code>git add &lt;file1&gt; &lt;file2&gt; ...</code></li><li>某个目录内：<code>git add [dir]</code></li></ol><p><strong>提交</strong></p><ol><li>将暂存区中的文件<mark>提交到本地仓库</mark>中，打上新版本：<code>git commit -m &quot;commit_info&quot;</code></li><li>将所有<strong>已跟踪</strong>文件暂存后一并提交：<code>git commit -a -m &quot;commit_info&quot;</code></li><li>修补提交，将此次提交合并到上一次提交中：<code>git commit --amend</code></li></ol><h2 id="打标签" tabindex="-1">打标签 <a class="header-anchor" href="#打标签" aria-label="Permalink to &quot;打标签&quot;">​</a></h2><p>给仓库历史中的某一个提交打上标签，以示重要，例如使用这个功能来标记<strong>发布结点</strong>。</p><p>Git 标签类型有两种：<strong>轻量标签</strong>和<strong>附注标签</strong>。</p><p><strong>轻量标签</strong>：指向特定提交对象的引用。 <strong>附注标签</strong>：存储在仓库中的一个独立对象，包含附注信息，如标签名，电子邮件，作者等。一般情况下用这个。</p><ol><li>列出现在所有的标签：<code>git tag</code></li><li>创建轻量标签：<code>git tag v1.5</code></li><li>创建附注标签：<code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code></li><li>对某个提交记录打标签：<code>git tag -a v1.4 7dksdged</code></li><li>查看相应标签信息：<code>git show v1.4</code></li><li>删除标签：<code>git tag -d v1.4</code></li></ol><h3 id="共享标签" tabindex="-1">共享标签 <a class="header-anchor" href="#共享标签" aria-label="Permalink to &quot;共享标签&quot;">​</a></h3><p>标签需要<strong>手动同步</strong>到远程仓库。</p><ol><li>指定标签推送：<code>git push origin v1.5</code></li><li>本地所有标签推送：<code>git push origin --tags</code></li><li>删除远程标签：<code>git push origin --delete v1.4</code></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>12.  6.  如果有自己的私钥，可以使用GPG来签署标签，只需要在命令中使用`-s`参数：`git tag -s v1.5 -m &quot;my signed 1.5 tag&quot;`;</span></span>\n<span class="line"><span>13.  验证已签署的标签：git tag -v ，如`git tag -v v1.5`;</span></span>\n<span class="line"><span>14.   使用特定的搜索模式列出符合条件的标签，例如只对1.4.2系列的版本感兴趣：`git tag -l &quot;v1.4.2.*&quot;`;</span></span></code></pre></div><h2 id="分支管理" tabindex="-1">分支管理 <a class="header-anchor" href="#分支管理" aria-label="Permalink to &quot;分支管理&quot;">​</a></h2><p><strong>Git的基本工作原理</strong>：Git 保存的不是文件的变化或者差异，而是一系列不同时刻的<strong>快照</strong>。在进行提交操作时，Git 会保存一个<strong>提交对象</strong>，该对象包含：提交信息、指向<strong>树对象</strong>的指针（包含所有文件快照的指针信息）、指向上次提交对象（<strong>父对象</strong>）的指针。</p><p>Git 的分支，本质上仅仅是指向提交对象的<strong>可变指针</strong>，其沿着指针链路构成一个分支。</p><p><img src="'+r+'" alt="image"></p><p><code>master</code>是默认分支。<code>HEAD</code>指针指向<mark>当前所在的本地分支</mark>，随着提交操作自动向前移动。</p><ol><li>创建分支：<code>git branch testing</code></li><li>切换到其他分支，此时<code>HEAD</code>指向该分支：<code>git checkout testing</code></li><li>新建并切换到分支上：<code>git checkout -b &lt;branch-name&gt;</code></li><li>删除分支：<code>git branch -d &lt;branch-name&gt;</code></li></ol><h3 id="分支合并" tabindex="-1">分支合并 <a class="header-anchor" href="#分支合并" aria-label="Permalink to &quot;分支合并&quot;">​</a></h3><p>将两个分支的内容合并在一起。</p><p><img src="'+l+`" alt="image"></p><p><strong>快进(fast-forward)</strong>：当顺着一个分支走下去能够到达另一个分支时，会简单地将指针向前推进。例如<code>hotfix</code>合并入<code>master</code>，会将<code>master</code>指针向前移。</p><p><strong>三方合并</strong>：两个分支分叉开时，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。</p><p>三方合并会产生一个提交——<strong>合并提交</strong>，指向两个分支的末端提交（C4 和 C5）。</p><ol><li>将指定分支合并入当前分支：<code>git merge hotfix</code></li><li>把远程分支合并到当前分支：<code>git merge &lt;remote-name&gt;/&lt;branch-name&gt;</code>。</li></ol><h3 id="冲突" tabindex="-1">冲突 <a class="header-anchor" href="#冲突" aria-label="Permalink to &quot;冲突&quot;">​</a></h3><p>当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></span>
<span class="line"><span>Creating a new branch is quick &amp; simple.</span></span>
<span class="line"><span>=======</span></span>
<span class="line"><span>Creating a new branch is quick AND simple.</span></span>
<span class="line"><span>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span></span></code></pre></div><h3 id="变基" tabindex="-1">变基 <a class="header-anchor" href="#变基" aria-label="Permalink to &quot;变基&quot;">​</a></h3><p>分支整合的另一种方式。将提交到某一分支上的所有修改都移至另一分支上。变基与合并的结果没有不同。但变基使得提交历史更加整洁。</p><p><img src="`+s+'" alt="image"></p><p>变基整合的流程为：</p><ol><li>将当前分支<code>test</code>变基到分支<code>master</code>：<code>git rebase master</code></li><li>切换回<code>master</code>：<code>git checkout master</code></li><li>快进合并：<code>git merge test</code></li></ol><p>如果想要将分支中的某个<mark>相对独立的部分</mark>变基。例如，在 <code>client</code> 分支里但不在<code>server</code> 分支里的修改，将它们变基在到 <code>master</code> 分支上：<code>git rebase --onto master server client</code>。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>一旦该分支发布到公共仓库，就千万不要对该分支进行rebase操作。</p></div><h3 id="查看信息" tabindex="-1">查看信息 <a class="header-anchor" href="#查看信息" aria-label="Permalink to &quot;查看信息&quot;">​</a></h3><ol><li>显示<strong>本地仓库</strong>的所有分支：<code>git branch</code></li><li>查看哪些分支已经合并到当前分支：<code>git branch --merged</code></li><li>查看哪些分支还没有合并到当前分支：<code>git branch --no-merged</code></li></ol><blockquote><p><mark>未合并的分支</mark>不能直接删除，要加<code>-D</code>选项。</p></blockquote><h2 id="远程仓库" tabindex="-1">远程仓库 <a class="header-anchor" href="#远程仓库" aria-label="Permalink to &quot;远程仓库&quot;">​</a></h2><p>克隆<code>git clone</code>一个远程仓库，远程仓库名默认为<code>origin</code>。</p><ol><li>查看本地仓库关联的远程仓库：<code>git remote -v</code></li><li>添加远程仓库：<code>git remote add [remote-name] [url]</code></li><li>从远程仓库中抓取本地仓库中没有的更新：<code>git fetch [remote-name]</code>。</li></ol><blockquote><p>包含所有分支的内容。使用fetch只是将远端数据拉到本地仓库，<mark>不会自动合并</mark>到当前工作分支。</p></blockquote><ol start="4"><li>远程仓库重命名：<code>git remote rename [old-name] [new-name]</code></li><li>移除远程仓库：<code>git remote rm [remote-name]</code></li><li>查看远程仓库的详细信息：<code>git remote show origin</code></li></ol><h3 id="远程分支" tabindex="-1">远程分支 <a class="header-anchor" href="#远程分支" aria-label="Permalink to &quot;远程分支&quot;">​</a></h3><p><strong>远程分支引用</strong>：利用<code>git fetch</code>抓取远程仓库数据时，在本地有远程分支的引用<code>&lt;remote&gt;/&lt;branch&gt;</code>。</p><p><strong>远程跟踪分支</strong>：关联某个远程分支的本地分支，对其进行数据抓取与合并。</p><blockquote><p>克隆一个仓库时，会自动地创建一个跟踪 origin/master 的 master分支。</p></blockquote><ol><li><p>创建并切换到远程跟踪分支： <code>git checkout -b &lt;branch &lt;remote&gt;/&lt;branch&gt;</code>。如果分支不存在且刚好只有一个名字与之匹配的远程分支，可使用<code>git checkout &lt;branch&gt;</code>。</p></li><li><p>拉取远程分支数据并入本地相应的远程跟踪分支：<code>git pull</code></p></li><li><p>推送数据并合并入相应的远程分支：<code>git push</code></p></li><li><p>将本地分支推送到远程仓库上：<code>git push [remote-name] [branch-name]</code>；不同名分支时：<code>git push &lt;remote-name&gt; &lt;local-branch&gt;:&lt;remote-branch&gt;</code>。</p></li><li><p>删除远程分支：<code>git push [romote-name] :&lt;remote-branch&gt;</code>，即把空白的本地分支推送到远程。也可以这样：<code>git push origin --delete &lt;remote-branch&gt;</code>。</p></li></ol><h2 id="文件忽略" tabindex="-1">文件忽略 <a class="header-anchor" href="#文件忽略" aria-label="Permalink to &quot;文件忽略&quot;">​</a></h2><p>通过编写<code>.gitignore</code> 文件来指定不需要进行版本管理的文件。</p><p>常见的，忽略以下文件：</p><ul><li>操作系统自动生成的文件，比如缩略图；</li><li>编译生成的中间文件，比如 Java 编译产生的 .class 文件；</li><li>自己的敏感信息，比如存放口令的配置文件。</li></ul><p>不需要全部自己编写，可以到 <a href="https://github.com/github/gitignore" target="_blank" rel="noreferrer">https://github.com/github/gitignore</a> 中进行查询。</p><h2 id="移除" tabindex="-1">移除 <a class="header-anchor" href="#移除" aria-label="Permalink to &quot;移除&quot;">​</a></h2><h3 id="删除文件" tabindex="-1">删除文件 <a class="header-anchor" href="#删除文件" aria-label="Permalink to &quot;删除文件&quot;">​</a></h3><ol><li><p>从当前目前中删除：<code>git rm file</code>。等同于手动删除<code>rm file</code>后<code>git add .</code>。如果该文件已被放入暂存区，则需添加<code>-f</code>参数。</p></li><li><p>如果仅是想将文件从<mark>跟踪清单中移除</mark>：<code>git rm --cached file</code>。</p></li></ol><h3 id="清理" tabindex="-1">清理 <a class="header-anchor" href="#清理" aria-label="Permalink to &quot;清理&quot;">​</a></h3><p>清理由外部工具生成的东西。譬如，在进行构建前清理前一次构建残留下东西。</p><ol><li>移除所有没有忽略的未跟踪文件：<code>git clean</code>。加<code>-x</code>参数移除包含已被忽略的文件。</li><li>强制移除所有默认的文件以及空的子目录：<code>git clean -f -d</code>。</li></ol><blockquote><p>移除前可通过<code>-n</code>参数看看哪些会被移除。</p></blockquote><h1 id="进阶" tabindex="-1">进阶 <a class="header-anchor" href="#进阶" aria-label="Permalink to &quot;进阶&quot;">​</a></h1><h2 id="重置" tabindex="-1">重置 <a class="header-anchor" href="#重置" aria-label="Permalink to &quot;重置&quot;">​</a></h2><p>通过操作<code>HEAD</code>指针和三个数据区来实现<strong>回滚</strong>操作。</p><p>重置回滚有三个程度，分别对应三个数据区。</p><p><strong>1.</strong> 仅回滚<strong>git目录</strong>：<code>git reset --soft HEAD~</code></p><p>将<code>HEAD</code>指针<mark>指向的分支</mark>移动到指定的提交记录<code>HAED~</code>(<code>HEAD</code>的父提交)，其他不做修改。此时仓库回滚到<code>git commit</code>之前的状态，因此修改文件后再度提交即可完成<code>git commit --amend</code>等同的操作。</p><blockquote><p>提交记录的指定，可以是记录的<code>SHA-1</code>校验和的前几位，也可以是<code>HEAD~i</code>（HEAD倒数的第<code>i</code>个提交）。</p></blockquote><p><strong>2.</strong> 回滚至<strong>暂存区</strong>：<code>git reset [--mixed] HEAD~</code></p><blockquote><p><strong>reset</strong> 的默认操作，即不指定任何选项时。</p></blockquote><p>将<code>HEAD</code>指针<mark>指向的分支</mark>移动到指定的提交记录，且将该记录覆盖暂存区。此时仓库回滚到<code>git commit</code>和<code>git add</code>之前的状态。</p><p><strong>3.</strong> 回滚至<strong>工作区</strong>：<code>git reset --hard HEAD~</code></p><p>将指定的提交覆盖暂存区及工作区，这会<mark>完全丢弃当前未提交的工作</mark>。</p><h3 id="指定文件" tabindex="-1">指定文件 <a class="header-anchor" href="#指定文件" aria-label="Permalink to &quot;指定文件&quot;">​</a></h3><p>可以指定特定的文件回滚至暂存区，而不移动<code>HEAD</code>指针。</p><p><code>git reset file.txt</code>将文件回滚至暂存区。（<code>git reset --mixed HEAD file.txt</code> 的简写形式）撤销最后一次的<code>git add file.txt</code>。</p><h2 id="检出" tabindex="-1">检出 <a class="header-anchor" href="#检出" aria-label="Permalink to &quot;检出&quot;">​</a></h2><p>检出指定的提交记录，覆盖至工作区。与<code>git reset --hard</code> 不同的是，<code>checkout</code><mark>对工作区是安全</mark>的，会试着将指定的提交<strong>合并</strong>至当前工作区。</p><p><code>reset</code> 会移动 <code>HEAD</code> 分支的指向，而 <code>checkout</code> 则移动 <code>HEAD</code> 自身。</p><p><img src="'+d+'" alt="image"></p><p><code>checkout</code>同样可以检出指定文件，通过<code>git checkout HEAD file.txt</code>。此时<code>HEAD</code>指针不移动，但指定的文件将<strong>强制</strong>覆盖至工作区。</p><h2 id="贮藏" tabindex="-1">贮藏 <a class="header-anchor" href="#贮藏" aria-label="Permalink to &quot;贮藏&quot;">​</a></h2><p>将处于进行中的工作临时存储在一个栈中，需要时再拿出来。用于在多个分支同时工作的情况中。</p><ol><li><p>存储当前工作区的所有<strong>已跟踪</strong>文件，并<strong>清空暂存区</strong>：<code>git stash</code>。</p></li><li><p>查看当前所有的贮藏：<code>git stash list</code>。</p></li><li><p>应用最新的贮藏：<code>git stash apply</code>；可以指定应用的贮藏：<code>git stash apply stash@{2}</code>。</p></li><li><p>移除指定的贮藏：<code>git stash drop stash@{0}</code>；或者直接应用并移除贮藏：<code>git stash pop</code>。</p></li><li><p>直接应用贮藏并不会恢复原来的暂存区，需加上<code>--index</code>参数：<code>git stash apply/pop --index</code>。</p></li><li><p>贮藏时不清空暂存区：<code>git stash --keep-index</code>。</p></li><li><p>包含未跟踪文件，但不包含git忽略的：加上<code>--include-untracked</code>参数。包含所有：<code>--all</code>。</p></li><li><p>从贮藏中创建分支，并移除贮藏：<code>git stash &lt;from-branch&gt; &lt;new-branch&gt;</code>。</p></li></ol><h1 id="ssh-传输设置" tabindex="-1">SSH 传输设置 <a class="header-anchor" href="#ssh-传输设置" aria-label="Permalink to &quot;SSH 传输设置&quot;">​</a></h1><p>Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。</p><p>如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span></span></code></pre></div><p>然后把公钥 id_rsa.pub 的内容复制到 Github &quot;Account settings&quot; 的 SSH Keys 中。</p><h1 id="命令一览" tabindex="-1">命令一览 <a class="header-anchor" href="#命令一览" aria-label="Permalink to &quot;命令一览&quot;">​</a></h1><p><img src="'+n+'" alt="avatar"><br></p><p>比较详细的地址：<a href="http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf" target="_blank" rel="noreferrer">http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf</a></p><h1 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h1><ul><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noreferrer">Git - 简明指南</a></li><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noreferrer">图解 Git</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noreferrer">廖雪峰 : Git 教程</a></li><li><a href="https://learngitbranching.js.org/" target="_blank" rel="noreferrer">Learn Git Branching</a></li></ul>',107)])])}const x=t(g,[["render",p]]);export{f as __pageData,x as default};
